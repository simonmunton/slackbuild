From c47f4d3f57a0ed5ddf5bda679754405334e77510 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 5 Aug 2021 10:12:35 -0400
Subject: [PATCH 08/13] dri: Epoch how no-error context creation works

The bug here is that the DRI context "flags" are meant to alias the GLX
context flag values, and they don't, DRI's no-error flag is GLX's
reset-isolation flag. GLX (and EGL!) treat no-error as a context
attribute, and reset isolation predates Mesa's no-error implementation
by several years. The GL_KHR_no_error does describe it as a "context
flag", though, so probably that's why we do it as a (DRI) context flag.

In order to unalias these we need a new contract with the driver. The
loaders will now only expose the winsys no-error extension if the driver
exposes __DRI2_NO_ERROR2, and the drivers only expose __DRI2_NO_ERROR2.
This new extension is a promise to expect no-error-ness as a context
attribute, matching the GLX and EGL calling convention.  We go ahead and
define __DRI_CTX_FLAG_RESET_ISOLATION as well, and update the drivers to
refuse it since we don't support it.

This means mismatched drivers/loaders will not be able to create
no-error contexts. Too bad. If you want performance that badly you can
build both things at once.
---
 include/GL/internal/dri_interface.h           | 29 +++++++++++-
 src/egl/drivers/dri2/egl_dri2.c               | 12 +++--
 src/egl/drivers/dri2/egl_dri2.h               |  2 +-
 src/gallium/frontends/dri/dri2.c              |  2 +-
 src/gallium/frontends/dri/dri_context.c       | 10 ++--
 src/gallium/frontends/dri/drisw.c             |  4 +-
 src/glx/dri2_glx.c                            | 30 +++++++-----
 src/glx/dri3_glx.c                            | 30 +++++++-----
 src/glx/dri_common.c                          | 46 ++++---------------
 src/glx/dri_common.h                          |  3 +-
 src/glx/drisw_glx.c                           | 28 ++++++-----
 src/mesa/drivers/dri/common/dri_util.c        | 21 ++++++---
 src/mesa/drivers/dri/common/dri_util.h        |  6 ++-
 src/mesa/drivers/dri/i915/intel_screen.c      |  4 +-
 src/mesa/drivers/dri/i965/brw_context.c       |  3 +-
 src/mesa/drivers/dri/i965/brw_screen.c        |  4 +-
 .../drivers/dri/nouveau/nouveau_context.c     |  2 +-
 src/mesa/drivers/dri/nouveau/nouveau_screen.c |  2 +-
 src/mesa/drivers/dri/r200/r200_context.c      |  2 +-
 src/mesa/drivers/dri/radeon/radeon_context.c  |  2 +-
 src/mesa/drivers/dri/radeon/radeon_screen.c   |  2 +-
 21 files changed, 137 insertions(+), 107 deletions(-)

diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index 6d98f2506bb..3b8d416276d 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -1204,16 +1204,23 @@ struct __DRIdri2LoaderExtensionRec {
 #define __DRI_CTX_ATTRIB_MAJOR_VERSION		0
 #define __DRI_CTX_ATTRIB_MINOR_VERSION		1
 
+/* These must alias the GLX/EGL values. */
 #define __DRI_CTX_ATTRIB_FLAGS			2
 #define __DRI_CTX_FLAG_DEBUG			0x00000001
 #define __DRI_CTX_FLAG_FORWARD_COMPATIBLE	0x00000002
 #define __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS	0x00000004
+/* Deprecated, do not use */
 #define __DRI_CTX_FLAG_NO_ERROR			0x00000008
+/* Not yet implemented but placed here to reserve the alias with GLX */
+#define __DRI_CTX_FLAG_RESET_ISOLATION          0x00000008
 
 #define __DRI_CTX_ATTRIB_RESET_STRATEGY		3
 #define __DRI_CTX_RESET_NO_NOTIFICATION		0
 #define __DRI_CTX_RESET_LOSE_CONTEXT		1
 
+/**
+ * \name Context priority levels.
+ */
 #define __DRI_CTX_ATTRIB_PRIORITY		4
 #define __DRI_CTX_PRIORITY_LOW			0
 #define __DRI_CTX_PRIORITY_MEDIUM		1
@@ -1223,7 +1230,9 @@ struct __DRIdri2LoaderExtensionRec {
 #define __DRI_CTX_RELEASE_BEHAVIOR_NONE         0
 #define __DRI_CTX_RELEASE_BEHAVIOR_FLUSH        1
 
-#define __DRI_CTX_NUM_ATTRIBS                   6
+#define __DRI_CTX_ATTRIB_NO_ERROR               6
+
+#define __DRI_CTX_NUM_ATTRIBS                   7
 
 /**
  * \name Reasons that __DRIdri2Extension::createContextAttribs might fail
@@ -1860,10 +1869,13 @@ struct __DRIrobustnessExtensionRec {
 };
 
 /**
- * No-error context driver extension.
+ * No-error context driver extension (deprecated).
  *
  * Existence of this extension means the driver can accept the
  * __DRI_CTX_FLAG_NO_ERROR flag.
+ *
+ * This extension is deprecated, and modern loaders will not use it. Please
+ * use __DRI2_NO_ERROR2 instead.
  */
 #define __DRI2_NO_ERROR "DRI_NoError"
 #define __DRI2_NO_ERROR_VERSION 1
@@ -1872,6 +1884,19 @@ typedef struct __DRInoErrorExtensionRec {
    __DRIextension base;
 } __DRInoErrorExtension;
 
+/*
+ * No-error context driver extension.
+ *
+ * Existence of this extension means the driver can accept the
+ * __DRI_CTX_ATTRIB_NO_ERROR attribute.
+ */
+#define __DRI2_NO_ERROR2 "DRI_NoError2"
+#define __DRI2_NO_ERROR2_VERSION 1
+
+typedef struct __DRInoError2ExtensionRec {
+   __DRIextension base;
+} __DRInoError2Extension;
+
 /*
  * Flush control driver extension.
  *
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 99b05579c71..edb238804b2 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -721,7 +721,7 @@ static const struct dri2_extension_match optional_driver_extensions[] = {
 
 static const struct dri2_extension_match optional_core_extensions[] = {
    { __DRI2_ROBUSTNESS, 1, offsetof(struct dri2_egl_display, robustness) },
-   { __DRI2_NO_ERROR, 1, offsetof(struct dri2_egl_display, no_error) },
+   { __DRI2_NO_ERROR2, 1, offsetof(struct dri2_egl_display, no_error) },
    { __DRI2_CONFIG_QUERY, 1, offsetof(struct dri2_egl_display, config) },
    { __DRI2_FENCE, 1, offsetof(struct dri2_egl_display, fence) },
    { __DRI2_BUFFER_DAMAGE, 1, offsetof(struct dri2_egl_display, buffer_damage) },
@@ -1388,7 +1388,7 @@ dri2_fill_context_attribs(struct dri2_egl_context *dri2_ctx,
    ctx_attribs[pos++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
    ctx_attribs[pos++] = dri2_ctx->base.ClientMinorVersion;
 
-   if (dri2_ctx->base.Flags != 0 || dri2_ctx->base.NoError) {
+   if (dri2_ctx->base.Flags != 0) {
       /* If the implementation doesn't support the __DRI2_ROBUSTNESS
        * extension, don't even try to send it the robust-access flag.
        * It may explode.  Instead, generate the required EGL error here.
@@ -1400,8 +1400,7 @@ dri2_fill_context_attribs(struct dri2_egl_context *dri2_ctx,
       }
 
       ctx_attribs[pos++] = __DRI_CTX_ATTRIB_FLAGS;
-      ctx_attribs[pos++] = dri2_ctx->base.Flags |
-         (dri2_ctx->base.NoError ? __DRI_CTX_FLAG_NO_ERROR : 0);
+      ctx_attribs[pos++] = dri2_ctx->base.Flags;
    }
 
    if (dri2_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION_KHR) {
@@ -1445,6 +1444,11 @@ dri2_fill_context_attribs(struct dri2_egl_context *dri2_ctx,
       ctx_attribs[pos++] = __DRI_CTX_RELEASE_BEHAVIOR_NONE;
    }
 
+   if (dri2_ctx->base.NoError) {
+      ctx_attribs[pos++] = __DRI_CTX_ATTRIB_NO_ERROR;
+      ctx_attribs[pos++] = true;
+   }
+
    *num_attribs = pos;
 
    return true;
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 6a7eedea112..c2b5f2868ed 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -192,7 +192,7 @@ struct dri2_egl_display
    const __DRItexBufferExtension  *tex_buffer;
    const __DRIimageExtension      *image;
    const __DRIrobustnessExtension *robustness;
-   const __DRInoErrorExtension    *no_error;
+   const __DRInoError2Extension    *no_error;
    const __DRI2configQueryExtension *config;
    const __DRI2fenceExtension *fence;
    const __DRI2bufferDamageExtension *buffer_damage;
diff --git a/src/gallium/frontends/dri/dri2.c b/src/gallium/frontends/dri/dri2.c
index 6dcbd3365c2..19621348c1e 100644
--- a/src/gallium/frontends/dri/dri2.c
+++ b/src/gallium/frontends/dri/dri2.c
@@ -2233,7 +2233,7 @@ static const __DRIextension *dri_screen_extensions_base[] = {
    &dri2ThrottleExtension.base,
    &dri2FenceExtension.base,
    &dri2InteropExtension.base,
-   &dri2NoErrorExtension.base,
+   &dri2NoError2Extension.base,
    &driBlobExtension.base,
    &driMutableRenderBufferExtension.base,
 };
diff --git a/src/gallium/frontends/dri/dri_context.c b/src/gallium/frontends/dri/dri_context.c
index 55bfa224bcf..1921b3cfe6b 100644
--- a/src/gallium/frontends/dri/dri_context.c
+++ b/src/gallium/frontends/dri/dri_context.c
@@ -57,11 +57,11 @@ dri_create_context(gl_api api, const struct gl_config * visual,
    struct st_context_attribs attribs;
    enum st_context_error ctx_err = 0;
    unsigned allowed_flags = __DRI_CTX_FLAG_DEBUG |
-                            __DRI_CTX_FLAG_FORWARD_COMPATIBLE |
-                            __DRI_CTX_FLAG_NO_ERROR;
+                            __DRI_CTX_FLAG_FORWARD_COMPATIBLE;
    unsigned allowed_attribs =
       __DRIVER_CONTEXT_ATTRIB_PRIORITY |
-      __DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR;
+      __DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR |
+      __DRIVER_CONTEXT_ATTRIB_NO_ERROR;
    const __DRIbackgroundCallableExtension *backgroundCallable =
       screen->sPriv->dri2.backgroundCallable;
    const struct driOptionCache *optionCache = &screen->dev->option_cache;
@@ -119,8 +119,8 @@ dri_create_context(gl_api api, const struct gl_config * visual,
       if (ctx_config->reset_strategy != __DRI_CTX_RESET_NO_NOTIFICATION)
          attribs.flags |= ST_CONTEXT_FLAG_RESET_NOTIFICATION_ENABLED;
 
-   if (ctx_config->flags & __DRI_CTX_FLAG_NO_ERROR)
-      attribs.flags |= ST_CONTEXT_FLAG_NO_ERROR;
+   if (ctx_config->attribute_mask & __DRIVER_CONTEXT_ATTRIB_NO_ERROR)
+      attribs.flags |= ctx_config->no_error ? ST_CONTEXT_FLAG_NO_ERROR : 0;
 
    if (ctx_config->attribute_mask & __DRIVER_CONTEXT_ATTRIB_PRIORITY) {
       switch (ctx_config->priority) {
diff --git a/src/gallium/frontends/dri/drisw.c b/src/gallium/frontends/dri/drisw.c
index 5f5d475c45f..2da77ca72ff 100644
--- a/src/gallium/frontends/dri/drisw.c
+++ b/src/gallium/frontends/dri/drisw.c
@@ -465,7 +465,7 @@ static const __DRIextension *drisw_screen_extensions[] = {
    &dri2RendererQueryExtension.base,
    &dri2ConfigQueryExtension.base,
    &dri2FenceExtension.base,
-   &dri2NoErrorExtension.base,
+   &dri2NoError2Extension.base,
    &driSWImageExtension.base,
    &dri2FlushControlExtension.base,
    NULL
@@ -476,7 +476,7 @@ static const __DRIextension *drisw_robust_screen_extensions[] = {
    &dri2RendererQueryExtension.base,
    &dri2ConfigQueryExtension.base,
    &dri2FenceExtension.base,
-   &dri2NoErrorExtension.base,
+   &dri2NoError2Extension.base,
    &dri2Robustness.base,
    &driSWImageExtension.base,
    &dri2FlushControlExtension.base,
diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index 2c14ccec3f3..e02372cccfb 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -198,10 +198,6 @@ dri2_create_context_attribs(struct glx_screen *base,
    if (*error != __DRI_CTX_ERROR_SUCCESS)
       goto error_exit;
 
-   if (!dri2_check_no_error(dca.flags, shareList, dca.major_ver, error)) {
-      goto error_exit;
-   }
-
    /* Check the renderType value */
    if (!validate_renderType_against_config(config_base, dca.render_type))
        goto error_exit;
@@ -211,6 +207,17 @@ dri2_create_context_attribs(struct glx_screen *base,
       if (!shareList->isDirect)
          return NULL;
 
+      /* The GLX_ARB_create_context_no_error specs say:
+       *
+       *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB
+       *    used to create <share_context> does not match the value of
+       *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
+       */
+      if (!!shareList->noError != !!dca.no_error) {
+         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         return NULL;
+      }
+
       pcp_shared = (struct dri2_context *) shareList;
       shared = pcp_shared->driContext;
    }
@@ -243,12 +250,14 @@ dri2_create_context_attribs(struct glx_screen *base,
       ctx_attribs[num_ctx_attribs++] = dca.release;
    }
 
+   if (dca.no_error) {
+      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_NO_ERROR;
+      ctx_attribs[num_ctx_attribs++] = dca.no_error;
+      pcp->base.noError = GL_TRUE;
+   }
+
    if (dca.flags != 0) {
       ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
-
-      /* The current __DRI_CTX_FLAG_* values are identical to the
-       * GLX_CONTEXT_*_BIT values.
-       */
       ctx_attribs[num_ctx_attribs++] = dca.flags;
    }
 
@@ -257,9 +266,6 @@ dri2_create_context_attribs(struct glx_screen *base,
     */
    pcp->base.renderType = dca.render_type;
 
-   if (dca.flags & __DRI_CTX_FLAG_NO_ERROR)
-      pcp->base.noError = GL_TRUE;
-
    pcp->driContext =
       (*psc->dri2->createContextAttribs) (psc->driScreen,
 					  dca.api,
@@ -1095,7 +1101,7 @@ dri2BindExtensions(struct dri2_screen *psc, struct glx_display * priv,
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_robustness");
 
-      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR) == 0)
+      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR2) == 0)
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_no_error");
 
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index b551a29d66a..9ec54669e84 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -249,10 +249,6 @@ dri3_create_context_attribs(struct glx_screen *base,
    if (*error != __DRI_CTX_ERROR_SUCCESS)
       goto error_exit;
 
-   if (!dri2_check_no_error(dca.flags, shareList, dca.major_ver, error)) {
-      goto error_exit;
-   }
-
    /* Check the renderType value */
    if (!validate_renderType_against_config(config_base, dca.render_type))
        goto error_exit;
@@ -262,6 +258,17 @@ dri3_create_context_attribs(struct glx_screen *base,
       if (!shareList->isDirect)
          return NULL;
 
+      /* The GLX_ARB_create_context_no_error specs say:
+       *
+       *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB
+       *    used to create <share_context> does not match the value of
+       *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
+       */
+      if (!!shareList->noError != !!dca.no_error) {
+         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         return NULL;
+      }
+
       pcp_shared = (struct dri3_context *) shareList;
       shared = pcp_shared->driContext;
    }
@@ -294,16 +301,15 @@ dri3_create_context_attribs(struct glx_screen *base,
       ctx_attribs[num_ctx_attribs++] = dca.release;
    }
 
+   if (dca.no_error) {
+      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_NO_ERROR;
+      ctx_attribs[num_ctx_attribs++] = dca.no_error;
+      pcp->base.noError = GL_TRUE;
+   }
+
    if (dca.flags != 0) {
       ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
-
-      /* The current __DRI_CTX_FLAG_* values are identical to the
-       * GLX_CONTEXT_*_BIT values.
-       */
       ctx_attribs[num_ctx_attribs++] = dca.flags;
-
-      if (dca.flags & __DRI_CTX_FLAG_NO_ERROR)
-         pcp->base.noError = GL_TRUE;
    }
 
    pcp->driContext =
@@ -772,7 +778,7 @@ dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_robustness");
 
-      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR) == 0)
+      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR2) == 0)
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_no_error");
 
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 99e3ac0df8e..4987c844929 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -423,7 +423,6 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                         struct dri_ctx_attribs *dca)
 {
    unsigned i;
-   int no_error = 0;
    uint32_t profile = GLX_CONTEXT_CORE_PROFILE_BIT_ARB;
 
    dca->major_ver = 1;
@@ -433,6 +432,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
    dca->release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;
    dca->flags = 0;
    dca->api = __DRI_API_OPENGL;
+   dca->no_error = 0;
 
    if (num_attribs == 0)
       return __DRI_CTX_ERROR_SUCCESS;
@@ -453,7 +453,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
 	 dca->flags = attribs[i * 2 + 1];
 	 break;
       case GLX_CONTEXT_OPENGL_NO_ERROR_ARB:
-	 no_error = attribs[i * 2 + 1];
+	 dca->no_error = attribs[i * 2 + 1];
 	 break;
       case GLX_CONTEXT_PROFILE_MASK_ARB:
 	 profile = attribs[i * 2 + 1];
@@ -496,10 +496,6 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
       }
    }
 
-   if (no_error) {
-      dca->flags |= __DRI_CTX_FLAG_NO_ERROR;
-   }
-
    switch (profile) {
    case GLX_CONTEXT_CORE_PROFILE_BIT_ARB:
       /* This is the default value, but there are no profiles before OpenGL
@@ -534,7 +530,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
    if (dca->flags & ~(__DRI_CTX_FLAG_DEBUG |
                       __DRI_CTX_FLAG_FORWARD_COMPATIBLE |
                       __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS |
-                      __DRI_CTX_FLAG_NO_ERROR))
+                      __DRI_CTX_FLAG_RESET_ISOLATION))
       return __DRI_CTX_ERROR_UNKNOWN_FLAG;
 
    /* There are no forward-compatible contexts before OpenGL 3.0.  The
@@ -549,34 +545,12 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
    if (dca->major_ver >= 3 && dca->render_type == GLX_COLOR_INDEX_TYPE)
       return __DRI_CTX_ERROR_BAD_FLAG;
 
-   return __DRI_CTX_ERROR_SUCCESS;
-}
-
-_X_HIDDEN bool
-dri2_check_no_error(uint32_t flags, struct glx_context *share_context,
-                    int major, unsigned *error)
-{
-   Bool noError = flags & __DRI_CTX_FLAG_NO_ERROR;
-
    /* The KHR_no_error specs say:
     *
     *    Requires OpenGL ES 2.0 or OpenGL 2.0.
     */
-   if (noError && major < 2) {
-      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
-      return false;
-   }
-
-   /* The GLX_ARB_create_context_no_error specs say:
-    *
-    *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB
-    *    used to create <share_context> does not match the value of
-    *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
-    */
-   if (share_context && !!share_context->noError != !!noError) {
-      *error = __DRI_CTX_ERROR_BAD_FLAG;
-      return false;
-   }
+   if (dca->no_error && dca->major_ver < 2)
+      return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
 
    /* The GLX_ARB_create_context_no_error specs say:
     *
@@ -584,13 +558,11 @@ dri2_check_no_error(uint32_t flags, struct glx_context *share_context,
     *    the same time as a debug or robustness context is specified.
     *
     */
-   if (noError && ((flags & __DRI_CTX_FLAG_DEBUG) ||
-                   (flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS))) {
-      *error = __DRI_CTX_ERROR_BAD_FLAG;
-      return false;
-   }
+   if (dca->no_error && ((dca->flags & __DRI_CTX_FLAG_DEBUG) ||
+                         (dca->flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)))
+      return __DRI_CTX_ERROR_BAD_FLAG;
 
-   return true;
+   return __DRI_CTX_ERROR_SUCCESS;
 }
 
 struct glx_context *
diff --git a/src/glx/dri_common.h b/src/glx/dri_common.h
index 455e8541ed8..1db01e58f77 100644
--- a/src/glx/dri_common.h
+++ b/src/glx/dri_common.h
@@ -74,6 +74,7 @@ struct dri_ctx_attribs {
    unsigned api;
    int reset;
    int release;
+   int no_error;
 };
 
 extern int
@@ -81,7 +82,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                         struct dri_ctx_attribs *dca);
 
 extern bool
-dri2_check_no_error(uint32_t flags, struct glx_context *share_context,
+dri2_check_no_error(Bool noError, struct glx_context *share_context,
                     int major, unsigned *error);
 
 
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index b1e9a1f4760..ce2e8a8f0a8 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -523,9 +523,6 @@ drisw_create_context_attribs(struct glx_screen *base,
    if (*error != __DRI_CTX_ERROR_SUCCESS)
       return NULL;
 
-   if (!dri2_check_no_error(dca.flags, shareList, dca.major_ver, error))
-      return NULL;
-
    /* Check the renderType value */
    if (!validate_renderType_against_config(config_base, dca.render_type)) {
        return NULL;
@@ -536,6 +533,17 @@ drisw_create_context_attribs(struct glx_screen *base,
       if (!shareList->isDirect)
          return NULL;
 
+      /* The GLX_ARB_create_context_no_error specs say:
+       *
+       *    BadMatch is generated if the value of GLX_CONTEXT_OPENGL_NO_ERROR_ARB
+       *    used to create <share_context> does not match the value of
+       *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
+       */
+      if (!!shareList->noError != !!dca.no_error) {
+         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         return NULL;
+      }
+
       pcp_shared = (struct drisw_context *) shareList;
       shared = pcp_shared->driContext;
    }
@@ -557,17 +565,15 @@ drisw_create_context_attribs(struct glx_screen *base,
        ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_RELEASE_BEHAVIOR;
        ctx_attribs[num_ctx_attribs++] = dca.release;
    }
+   if (dca.no_error) {
+       ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_NO_ERROR;
+       ctx_attribs[num_ctx_attribs++] = GL_TRUE;
+       pcp->base.noError = GL_TRUE;
+   }
 
    if (dca.flags != 0) {
       ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
-
-      /* The current __DRI_CTX_FLAG_* values are identical to the
-       * GLX_CONTEXT_*_BIT values.
-       */
       ctx_attribs[num_ctx_attribs++] = dca.flags;
-
-      if (dca.flags & __DRI_CTX_FLAG_NO_ERROR)
-         pcp->base.noError = GL_TRUE;
    }
 
    pcp->base.renderType = dca.render_type;
@@ -778,7 +784,7 @@ driswBindExtensions(struct drisw_screen *psc, const __DRIextension **extensions)
 				     "GLX_ARB_context_flush_control");
       }
 
-      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR) == 0)
+      if (strcmp(extensions[i]->name, __DRI2_NO_ERROR2) == 0)
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_no_error");
    }
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index f379cef06f1..902a49f6503 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -378,6 +378,16 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
                     ~__DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR;
             }
             break;
+        case __DRI_CTX_ATTRIB_NO_ERROR:
+            if (attribs[i * 2 + 1] != 0) {
+               ctx_config.attribute_mask |=
+                  __DRIVER_CONTEXT_ATTRIB_NO_ERROR;
+               ctx_config.no_error = attribs[i * 2 + 1];
+            } else {
+               ctx_config.attribute_mask &=
+                  ~__DRIVER_CONTEXT_ATTRIB_NO_ERROR;
+            }
+            break;
 	default:
 	    /* We can't create a context that satisfies the requirements of an
 	     * attribute that we don't understand.  Return failure.
@@ -429,8 +439,7 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
     if (mesa_api != API_OPENGL_COMPAT
         && mesa_api != API_OPENGL_CORE
         && (ctx_config.flags & ~(__DRI_CTX_FLAG_DEBUG |
-                                 __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS |
-                                 __DRI_CTX_FLAG_NO_ERROR))) {
+                                 __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS))) {
 	*error = __DRI_CTX_ERROR_BAD_FLAG;
 	return NULL;
     }
@@ -453,7 +462,7 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
     const uint32_t allowed_flags = (__DRI_CTX_FLAG_DEBUG
                                     | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
                                     | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS
-                                    | __DRI_CTX_FLAG_NO_ERROR);
+                                    | __DRI_CTX_FLAG_RESET_ISOLATION);
     if (ctx_config.flags & ~allowed_flags) {
 	*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
 	return NULL;
@@ -496,8 +505,6 @@ driContextSetFlags(struct gl_context *ctx, uint32_t flags)
        _mesa_set_debug_state_int(ctx, GL_DEBUG_OUTPUT, GL_TRUE);
         ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
     }
-    if ((flags & __DRI_CTX_FLAG_NO_ERROR) != 0)
-        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR;
 }
 
 static __DRIcontext *
@@ -1071,6 +1078,6 @@ const __DRIcopySubBufferExtension driCopySubBufferExtension = {
    .copySubBuffer               = driCopySubBuffer,
 };
 
-const __DRInoErrorExtension dri2NoErrorExtension = {
-   .base = { __DRI2_NO_ERROR, 1 },
+const __DRInoError2Extension dri2NoError2Extension = {
+   .base = { __DRI2_NO_ERROR2, 1 },
 };
diff --git a/src/mesa/drivers/dri/common/dri_util.h b/src/mesa/drivers/dri/common/dri_util.h
index 1bc84ebddaa..96470576485 100644
--- a/src/mesa/drivers/dri/common/dri_util.h
+++ b/src/mesa/drivers/dri/common/dri_util.h
@@ -101,11 +101,15 @@ struct __DriverContextConfig {
 
     /* Only valid if __DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR is set */
     int release_behavior;
+
+    /* Only valid if __DRIVER_CONTEXT_ATTRIB_NO_ERROR is set */
+    int no_error;
 };
 
 #define __DRIVER_CONTEXT_ATTRIB_RESET_STRATEGY   (1 << 0)
 #define __DRIVER_CONTEXT_ATTRIB_PRIORITY         (1 << 1)
 #define __DRIVER_CONTEXT_ATTRIB_RELEASE_BEHAVIOR (1 << 2)
+#define __DRIVER_CONTEXT_ATTRIB_NO_ERROR         (1 << 3)
 
 /**
  * Driver callback functions.
@@ -337,6 +341,6 @@ driContextSetFlags(struct gl_context *ctx, uint32_t flags);
 
 extern const __DRIimageDriverExtension driImageDriverExtension;
 
-extern const __DRInoErrorExtension dri2NoErrorExtension;
+extern const __DRInoError2Extension dri2NoError2Extension;
 
 #endif /* _DRI_UTIL_H_ */
diff --git a/src/mesa/drivers/dri/i915/intel_screen.c b/src/mesa/drivers/dri/i915/intel_screen.c
index 6135357c2a0..03926848a7e 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.c
+++ b/src/mesa/drivers/dri/i915/intel_screen.c
@@ -814,7 +814,7 @@ static const __DRIextension *intelScreenExtensions[] = {
     &intelImageExtension.base,
     &intelRendererQueryExtension.base,
     &dri2ConfigQueryExtension.base,
-    &dri2NoErrorExtension.base,
+    &dri2NoError2Extension.base,
     NULL
 };
 
@@ -980,7 +980,7 @@ intelCreateContext(gl_api api,
    __DRIscreen *sPriv = driContextPriv->driScreenPriv;
    struct intel_screen *intelScreen = sPriv->driverPrivate;
 
-   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_NO_ERROR)) {
+   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG)) {
       *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
       return false;
    }
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 097dd9cb1dc..a9490eb3798 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -972,8 +972,7 @@ brw_create_context(gl_api api,
     * provides us with context reset notifications.
     */
    uint32_t allowed_flags = __DRI_CTX_FLAG_DEBUG |
-                            __DRI_CTX_FLAG_FORWARD_COMPATIBLE |
-                            __DRI_CTX_FLAG_NO_ERROR;
+                            __DRI_CTX_FLAG_FORWARD_COMPATIBLE;
 
    if (screen->has_context_reset_notification)
       allowed_flags |= __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS;
diff --git a/src/mesa/drivers/dri/i965/brw_screen.c b/src/mesa/drivers/dri/i965/brw_screen.c
index 227d31d59c3..919376bf88e 100644
--- a/src/mesa/drivers/dri/i965/brw_screen.c
+++ b/src/mesa/drivers/dri/i965/brw_screen.c
@@ -1680,7 +1680,7 @@ static const __DRIextension *screenExtensions[] = {
     &brwRendererQueryExtension.base,
     &brwMutableRenderBufferExtension.base,
     &dri2ConfigQueryExtension.base,
-    &dri2NoErrorExtension.base,
+    &dri2NoError2Extension.base,
     &brwBlobExtension.base,
     NULL
 };
@@ -1694,7 +1694,7 @@ static const __DRIextension *brwRobustScreenExtensions[] = {
     &brwMutableRenderBufferExtension.base,
     &dri2ConfigQueryExtension.base,
     &dri2Robustness.base,
-    &dri2NoErrorExtension.base,
+    &dri2NoError2Extension.base,
     &brwBlobExtension.base,
     NULL
 };
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_context.c b/src/mesa/drivers/dri/nouveau/nouveau_context.c
index 014b3061e43..9fc39d285d1 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_context.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_context.c
@@ -60,7 +60,7 @@ nouveau_context_create(gl_api api,
 	struct nouveau_context *nctx;
 	struct gl_context *ctx;
 
-	if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_NO_ERROR)) {
+	if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG)) {
 		*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
 		return false;
 	}
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_screen.c b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
index c92efcd7b20..abb15b26756 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_screen.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
@@ -325,7 +325,7 @@ static const __DRIextension *nouveau_screen_extensions[] = {
     &nouveau_texbuffer_extension.base,
     &nouveau_renderer_query_extension.base,
     &dri2ConfigQueryExtension.base,
-    &dri2NoErrorExtension.base,
+    &dri2NoError2Extension.base,
     NULL
 };
 
diff --git a/src/mesa/drivers/dri/r200/r200_context.c b/src/mesa/drivers/dri/r200/r200_context.c
index d7264deca29..88b369df89d 100644
--- a/src/mesa/drivers/dri/r200/r200_context.c
+++ b/src/mesa/drivers/dri/r200/r200_context.c
@@ -187,7 +187,7 @@ GLboolean r200CreateContext( gl_api api,
    int i;
    int tcl_mode;
 
-   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_NO_ERROR)) {
+   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG)) {
       *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
       return false;
    }
diff --git a/src/mesa/drivers/dri/radeon/radeon_context.c b/src/mesa/drivers/dri/radeon/radeon_context.c
index 5c56ca99f12..28cfeee97f1 100644
--- a/src/mesa/drivers/dri/radeon/radeon_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_context.c
@@ -152,7 +152,7 @@ r100CreateContext( gl_api api,
    int i;
    int tcl_mode, fthrottle_mode;
 
-   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_NO_ERROR)) {
+   if (ctx_config->flags & ~(__DRI_CTX_FLAG_DEBUG)) {
       *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
       return false;
    }
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index 3764a5d6538..003542bf0e7 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -559,7 +559,7 @@ static const __DRIextension *radeon_screen_extensions[] = {
     &radeonFlushExtension.base,
     &radeonImageExtension.base,
     &radeonRendererQueryExtension.base,
-    &dri2NoErrorExtension.base,
+    &dri2NoError2Extension.base,
     NULL
 };
 
-- 
GitLab


From 4abd03f6f6782fea98645bea6a4b6154bb74152f Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 21 Jul 2021 18:05:12 -0400
Subject: [PATCH 09/13] glx/dri: Use X/GLX error codes for our
 create_context_attribs

This has no functional change because everyone calling this is
discarding the error code, because we're relying on the server to
generate the right thing for us. But we create the direct context first
and the server isn't going to enforce everything we want it to
(supported GL versions for example). Convert out from DRI error codes to
X/GLX error codes so we can fail the right way on the client side. We're
still throwing the error away in all of the callers but that'll change
shortly.
---
 src/glx/dri2_glx.c     |  6 +++--
 src/glx/dri3_glx.c     |  6 +++--
 src/glx/dri_common.c   | 56 ++++++++++++++++++++++++++++--------------
 src/glx/dri_common.h   |  2 ++
 src/glx/drisw_glx.c    |  5 +++-
 src/glx/glxclient.h    |  6 +++++
 src/glx/indirect_glx.c |  5 ++++
 7 files changed, 63 insertions(+), 23 deletions(-)

diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index e02372cccfb..2b17b91fdeb 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -214,7 +214,7 @@ dri2_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -224,7 +224,7 @@ dri2_create_context_attribs(struct glx_screen *base,
 
    pcp = calloc(1, sizeof *pcp);
    if (pcp == NULL) {
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      *error = BadAlloc;
       goto error_exit;
    }
 
@@ -276,6 +276,8 @@ dri2_create_context_attribs(struct glx_screen *base,
 					  error,
 					  pcp);
 
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL)
       goto error_exit;
 
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 9ec54669e84..f539e43a81d 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -265,7 +265,7 @@ dri3_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -275,7 +275,7 @@ dri3_create_context_attribs(struct glx_screen *base,
 
    pcp = calloc(1, sizeof *pcp);
    if (pcp == NULL) {
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      *error = BadAlloc;
       goto error_exit;
    }
 
@@ -323,6 +323,8 @@ dri3_create_context_attribs(struct glx_screen *base,
                                                   error,
                                                   pcp);
 
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL)
       goto error_exit;
 
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 4987c844929..e0ae7891901 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -434,13 +434,6 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
    dca->api = __DRI_API_OPENGL;
    dca->no_error = 0;
 
-   if (num_attribs == 0)
-      return __DRI_CTX_ERROR_SUCCESS;
-
-   /* This is actually an internal error, but what the heck. */
-   if (attribs == NULL)
-      return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
-
    for (i = 0; i < num_attribs; i++) {
       switch (attribs[i * 2]) {
       case GLX_CONTEXT_MAJOR_VERSION_ARB:
@@ -470,7 +463,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
             dca->reset = __DRI_CTX_RESET_LOSE_CONTEXT;
             break;
          default:
-            return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+            return BadValue;
          }
          break;
       case GLX_CONTEXT_RELEASE_BEHAVIOR_ARB:
@@ -482,7 +475,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
             dca->release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;
             break;
          default:
-            return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+            return BadValue;
          }
          break;
       case GLX_SCREEN:
@@ -492,7 +485,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
       default:
 	 /* If an unknown attribute is received, fail.
 	  */
-	 return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+	 return BadValue;
       }
    }
 
@@ -519,11 +512,11 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
       else if (dca->major_ver == 1 && dca->minor_ver < 2)
          dca->api = __DRI_API_GLES;
       else {
-         return __DRI_CTX_ERROR_BAD_API;
+         return BadValue;
       }
       break;
    default:
-      return __DRI_CTX_ERROR_BAD_API;
+      return GLXBadProfileARB;
    }
 
    /* Unknown flag value */
@@ -531,7 +524,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                       __DRI_CTX_FLAG_FORWARD_COMPATIBLE |
                       __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS |
                       __DRI_CTX_FLAG_RESET_ISOLATION))
-      return __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return BadValue;
 
    /* There are no forward-compatible contexts before OpenGL 3.0.  The
     * GLX_ARB_create_context spec says:
@@ -540,17 +533,23 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
     *     3.0 and later."
     */
    if (dca->major_ver < 3 && (dca->flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
+   /* It also says:
+    *
+    *    "OpenGL contexts supporting version 3.0 or later of the API do not
+    *    support color index rendering, even if a color index <config> is
+    *    available."
+    */
    if (dca->major_ver >= 3 && dca->render_type == GLX_COLOR_INDEX_TYPE)
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
    /* The KHR_no_error specs say:
     *
     *    Requires OpenGL ES 2.0 or OpenGL 2.0.
     */
    if (dca->no_error && dca->major_ver < 2)
-      return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      return BadMatch;
 
    /* The GLX_ARB_create_context_no_error specs say:
     *
@@ -560,9 +559,30 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
     */
    if (dca->no_error && ((dca->flags & __DRI_CTX_FLAG_DEBUG) ||
                          (dca->flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)))
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
-   return __DRI_CTX_ERROR_SUCCESS;
+   return Success;
+}
+
+unsigned
+dri_context_error_to_glx_error(unsigned error)
+{
+   if (error == __DRI_CTX_ERROR_SUCCESS)
+      return Success;
+   if (error == __DRI_CTX_ERROR_NO_MEMORY)
+      return BadAlloc;
+   else if (error == __DRI_CTX_ERROR_BAD_API)
+      return BadMatch;
+   else if (error == __DRI_CTX_ERROR_BAD_VERSION)
+      return GLXBadFBConfig;
+   else if (error == __DRI_CTX_ERROR_BAD_FLAG)
+      return BadMatch;
+   else if (error == __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE)
+      return BadValue;
+   else if (error == __DRI_CTX_ERROR_UNKNOWN_FLAG)
+      return BadValue;
+   else
+      unreachable("Impossible DRI context error");
 }
 
 struct glx_context *
diff --git a/src/glx/dri_common.h b/src/glx/dri_common.h
index 1db01e58f77..79593491ee6 100644
--- a/src/glx/dri_common.h
+++ b/src/glx/dri_common.h
@@ -85,6 +85,8 @@ extern bool
 dri2_check_no_error(Bool noError, struct glx_context *share_context,
                     int major, unsigned *error);
 
+extern unsigned
+dri_context_error_to_glx_error(unsigned error);
 
 extern struct glx_context *
 dri_common_create_context(struct glx_screen *base,
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index ce2e8a8f0a8..72510beb15f 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -540,7 +540,7 @@ drisw_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -587,6 +587,9 @@ drisw_create_context_attribs(struct glx_screen *base,
 					    ctx_attribs,
 					    error,
 					    pcp);
+
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL) {
       free(pcp);
       return NULL;
diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 9e304b75761..4802b40d407 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -483,6 +483,12 @@ struct glx_screen_vtable {
 					 struct glx_context *shareList,
 					 int renderType);
 
+   /* The error outparameter here abuses the fact that the only possible
+    * errors are are GLXBadContext (0), GLXBadFBConfig (9), GLXBadProfileARB
+    * (13), BadValue (2), BadMatch (8), and BadAlloc (11). Since those don't
+    * collide we just use them directly rather than try to offset or use
+    * a sign convention.
+    */
    struct glx_context *(*create_context_attribs)(struct glx_screen *psc,
 						 struct glx_config *config,
 						 struct glx_context *shareList,
diff --git a/src/glx/indirect_glx.c b/src/glx/indirect_glx.c
index 4fb4ddecc0d..7cab5c380b2 100644
--- a/src/glx/indirect_glx.c
+++ b/src/glx/indirect_glx.c
@@ -273,6 +273,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
 
    opcode = __glXSetupForCommand(psc->dpy);
    if (!opcode) {
+      *error = BadImplementation;
       return NULL;
    }
 
@@ -295,6 +296,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    if (mask != GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB ||
        major != 1 ||
        minor > 4) {
+      *error = GLXBadFBConfig;
       return NULL;
    }
 
@@ -305,6 +307,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    /* Allocate our context record */
    gc = calloc(1, sizeof *gc);
    if (!gc) {
+      *error = BadAlloc;
       /* Out of memory */
       return NULL;
    }
@@ -317,6 +320,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
 
    if (state == NULL) {
       /* Out of memory */
+      *error = BadAlloc;
       free(gc);
       return NULL;
    }
@@ -333,6 +337,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    bufSize = (XMaxRequestSize(psc->dpy) * 4) - sz_xGLXRenderReq;
    gc->buf = malloc(bufSize);
    if (!gc->buf) {
+      *error = BadAlloc;
       free(gc->client_state_private);
       free(gc);
       return NULL;
-- 
GitLab


From 885a8366813339a930b9e972531fc0c9c3970e4a Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 22 Jul 2021 16:28:31 -0400
Subject: [PATCH 10/13] glx/dri: Validate more of the context version in
 validate_context_version

There's two kinds of "bad version" you might encounter here, either the
combination does not name a defined version (like 1.7) or it names
something the driver can't do (like asking r300 to do 4.0), and you have
to distinguish to generate BadMatch vs GLXBadFBConfig correctly.

While we're at it just return the status directly rather than
bool+outparam.
---
 src/mesa/drivers/dri/common/dri_util.c | 67 +++++++++++++++-----------
 1 file changed, 38 insertions(+), 29 deletions(-)

diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index 902a49f6503..47d32fc672e 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -251,44 +251,53 @@ static const __DRIextension **driGetExtensions(__DRIscreen *psp)
 
 /*@}*/
 
-
-static bool
+static unsigned
 validate_context_version(__DRIscreen *screen,
                          int mesa_api,
                          unsigned major_version,
-                         unsigned minor_version,
-                         unsigned *dri_ctx_error)
+                         unsigned minor_version)
 {
    unsigned req_version = 10 * major_version + minor_version;
    unsigned max_version = 0;
 
-   switch (mesa_api) {
-   case API_OPENGL_COMPAT:
+   if (major_version == 0 || major_version > 4)
+      return __DRI_CTX_ERROR_BAD_API;
+
+   if (mesa_api == API_OPENGL_COMPAT) {
+      if ((major_version == 4 && minor_version > 6) ||
+          (major_version == 3 && minor_version > 3) ||
+          (major_version == 2 && minor_version > 1) ||
+          (major_version == 1 && minor_version > 5))
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_compat_version;
-      break;
-   case API_OPENGL_CORE:
-      max_version = screen->max_gl_core_version;
-      break;
-   case API_OPENGLES:
+   } else if (mesa_api == API_OPENGLES) {
+      if (major_version > 1 || minor_version > 1)
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_es1_version;
-      break;
-   case API_OPENGLES2:
+   } else if (mesa_api == API_OPENGLES2) {
+      if ((major_version >  3) ||
+          (major_version == 3 && minor_version > 2) ||
+          (major_version == 2 && minor_version > 0) ||
+          (major_version <  2))
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_es2_version;
-      break;
-   default:
-      max_version = 0;
-      break;
+   } else if (mesa_api == API_OPENGL_CORE) {
+      if ((major_version == 4 && minor_version > 6) ||
+          (major_version == 3 && (minor_version > 3 || minor_version < 2)) ||
+          (major_version < 3))
+         return __DRI_CTX_ERROR_BAD_API;
+      max_version = screen->max_gl_core_version;
+   } else {
+      return __DRI_CTX_ERROR_BAD_API;
    }
 
-   if (max_version == 0) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
-      return false;
-   } else if (req_version > max_version) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
-      return false;
-   }
+   if (max_version == 0)
+      return __DRI_CTX_ERROR_BAD_API;
+
+   if (req_version > max_version)
+      return __DRI_CTX_ERROR_BAD_VERSION;
 
-   return true;
+   return __DRI_CTX_ERROR_SUCCESS;
 }
 
 /*****************************************************************/
@@ -468,10 +477,10 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
 	return NULL;
     }
 
-    if (!validate_context_version(screen, mesa_api,
-                                  ctx_config.major_version,
-                                  ctx_config.minor_version,
-                                  error))
+    *error = validate_context_version(screen, mesa_api,
+                                      ctx_config.major_version,
+                                      ctx_config.minor_version);
+    if (*error != __DRI_CTX_ERROR_SUCCESS)
        return NULL;
 
     context = calloc(1, sizeof *context);
-- 
GitLab


From a84ffdc7e43b26867419f46628d246e718fe34fe Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 23 Jul 2021 18:14:33 -0400
Subject: [PATCH 11/13] glx/dri: Fix error generation for invalid
 GLX_RENDER_TYPE

This needs to throw BadValue.
---
 src/glx/dri2_glx.c  | 6 ++++--
 src/glx/dri3_glx.c  | 6 ++++--
 src/glx/drisw_glx.c | 3 ++-
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index 2b17b91fdeb..7f8132330ec 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -199,8 +199,10 @@ dri2_create_context_attribs(struct glx_screen *base,
       goto error_exit;
 
    /* Check the renderType value */
-   if (!validate_renderType_against_config(config_base, dca.render_type))
-       goto error_exit;
+   if (!validate_renderType_against_config(config_base, dca.render_type)) {
+      *error = BadValue;
+      goto error_exit;
+   }
 
    if (shareList) {
       /* We can't share with an indirect context */
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index f539e43a81d..923900c22bb 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -250,8 +250,10 @@ dri3_create_context_attribs(struct glx_screen *base,
       goto error_exit;
 
    /* Check the renderType value */
-   if (!validate_renderType_against_config(config_base, dca.render_type))
-       goto error_exit;
+   if (!validate_renderType_against_config(config_base, dca.render_type)) {
+      *error = BadValue;
+      goto error_exit;
+   }
 
    if (shareList) {
       /* We can't share with an indirect context */
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index 72510beb15f..5d4fcecbf47 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -525,7 +525,8 @@ drisw_create_context_attribs(struct glx_screen *base,
 
    /* Check the renderType value */
    if (!validate_renderType_against_config(config_base, dca.render_type)) {
-       return NULL;
+      *error = BadValue;
+      return NULL;
    }
 
    if (shareList) {
-- 
GitLab


From bd3295bb874ce63e706c4329b49d075c1d4b7ca5 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 23 Jul 2021 16:13:45 -0400
Subject: [PATCH 12/13] glx: disable the indirect fallback in
 CreateContextAttribs

If your app cares enough to use CreateContextAttribs it's probably not
going to be happy with the pre-GL-1.5 indirect experience.
---
 src/glx/create_context.c | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/glx/create_context.c b/src/glx/create_context.c
index 7e1cec98c64..f1af41d7a21 100644
--- a/src/glx/create_context.c
+++ b/src/glx/create_context.c
@@ -100,16 +100,15 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
       gc = psc->vtable->create_context_attribs(psc, cfg, share, num_attribs,
 					       (const uint32_t *) attrib_list,
 					       &dummy_err);
-   }
-
-   if (gc == NULL) {
+   } 
 #ifdef GLX_USE_APPLEGL
+   else if (gc == NULL) {
       gc = applegl_create_context(psc, cfg, share, 0);
-#else
-      gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
-              (const uint32_t *) attrib_list,
-              &dummy_err);
 #endif
+   else if (!direct) {
+      gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
+                                           (const uint32_t *) attrib_list,
+                                           &dummy_err);
    }
 
    xid = xcb_generate_id(c);
-- 
GitLab


From efc82ca2fd76547690b0194dc66ef141da5d6c7d Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 21 Jul 2021 12:02:35 -0400
Subject: [PATCH 13/13] glx: Fix error handling yet again in
 CreateContextAttribs

Unlike the legacy CreateContext path, we would try to send the
GLXCreateContextAttribs request regardless of whether we'd successfully
created the client context state. And there's not a lot on the server
side to go wrong besides BadAlloc, so if the request succeeded but
the client side didn't we'd need to destroy the server context and
synthesize an X error. Since that itself involves more X protocol it's
tricky to get the request number right in the error, and tests and apps
can notice when you get it wrong.

Since we have now fixed client-side validation to generate the right
errors at the right times, this patch does something simpler, we match
CreateContext and fail early if the client-side setup fails. Now there's
no question of what request number to use, because we haven't sent any
protocol, the error is for the request as if it'd been sent.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/4763
---
 src/glx/create_context.c | 42 +++++++++++++++++++---------------------
 1 file changed, 20 insertions(+), 22 deletions(-)

diff --git a/src/glx/create_context.c b/src/glx/create_context.c
index f1af41d7a21..12e68e672a6 100644
--- a/src/glx/create_context.c
+++ b/src/glx/create_context.c
@@ -54,7 +54,7 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
    struct glx_screen *psc;
    xcb_generic_error_t *err;
    xcb_void_cookie_t cookie;
-   unsigned dummy_err = 0;
+   unsigned error = BadImplementation;
    uint32_t xid, share_xid;
    int screen = -1;
 
@@ -92,23 +92,30 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
 
    assert(screen == psc->scr);
 
+#ifdef GLX_USE_APPLEGL
+   gc = applegl_create_context(psc, cfg, share, 0);
+#else
    if (direct && psc->vtable->create_context_attribs) {
-      /* GLX drops the error returned by the driver.  The expectation is that
-       * an error will also be returned by the server.  The server's error
-       * will be delivered to the application.
-       */
       gc = psc->vtable->create_context_attribs(psc, cfg, share, num_attribs,
 					       (const uint32_t *) attrib_list,
-					       &dummy_err);
-   } 
-#ifdef GLX_USE_APPLEGL
-   else if (gc == NULL) {
-      gc = applegl_create_context(psc, cfg, share, 0);
-#endif
-   else if (!direct) {
+					       &error);
+   } else if (!direct) {
       gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
                                            (const uint32_t *) attrib_list,
-                                           &dummy_err);
+                                           &error);
+   }
+#endif
+
+   if (gc == NULL) {
+      /* -1 isn't a legal XID, which is sort of the point, we've failed
+       * before we even got to XID allocation.
+       */
+      if (error == GLXBadContext || error == GLXBadFBConfig ||
+          error == GLXBadProfileARB)
+         __glXSendError(dpy, error, -1, 0, False);
+      else
+         __glXSendError(dpy, error, -1, 0, True);
+      return NULL;
    }
 
    xid = xcb_generate_id(c);
@@ -140,15 +147,6 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
 
       __glXSendErrorForXcb(dpy, err);
       free(err);
-   } else if (!gc) {
-      /* the server thought the context description was okay, but we failed
-       * somehow on the client side. clean up the server resource and panic.
-       */
-      xcb_glx_destroy_context(c, xid);
-      /* increment dpy->request in order to give a unique serial number to the
-       * error */
-      XNoOp(dpy);
-      __glXSendError(dpy, GLXBadFBConfig, xid, 0, False);
    } else {
       gc->xid = xid;
       gc->share_xid = share_xid;
-- 
GitLab

