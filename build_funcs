# build utility functions
#
CWD=`pwd`

DO_CONFIGURE=yes
DO_MAKE=yes
DO_INSTALL=yes
NUM_JOBS="-j 1"


# Note that we use `"$@"' to let each command-line parameter expand to a
# separate word. The quotes around `$@' are essential!
# We need OPTS as the `eval set --' would nuke the return value of getopt.

OPTS=`getopt -o cmij: --long disable-configure,disable-make,disable-install,num-jobs: \
     -n "$0" -- "$@"`

# Note the quotes around `$OPTS': they are essential!
eval set -- "${OPTS}"

while true ; do
  case "$1" in
    -c|--disable-configure)  DO_CONFIGURE=no; shift ;;
    -m|--disable-make)       DO_MAKE=no; shift ;;
    -i|--disable-install)    DO_INSTALL=no; shift ;;
    -j|--num-jobs)	     NUM_JOBS="-j $2"; shift 2 ;;
    --) shift ; break ;;
  esac
done




guess_tar_prog ()
{
# guess tar program and tar opts

case $1 in
  *.tar.gz|*.tgz)
    : ${TAR_PROG:=tar}
    : ${TAR_OPTS:=xzvf}
    ;;

  *.tar.bz2|*.tbz)
    : ${TAR_PROG:=tar}
    : ${TAR_OPTS:=xjvf}
    ;;

  *.zip)
    : ${TAR_PROG:=unzip}
    : ${TAR_OPTS:=}
    ;;

  *.7z)
    : ${TAR_PROG:=7z}
    : ${TAR_OPTS:=x}
    ;;
esac
}

unpack ()
{
guess_tar_prog $1

${TAR_PROG} ${TAR_OPTS} $1
}

pre_unpack ()
{
USERNAME=`id -un`
GROUP=`id -gn`

: ${PKGNAME:=$TARNAME}
: ${PKGVERSION:=${VERSION//-/_}}
: ${BUILD_SUFFIX:=sm}

: ${ARCH:=i486}

# if TAR_EXT not set, try and guess it
#
if [ "x${TAR_EXT}" == "x" ]
then
  if [ -f ${FULL_TARNAME}.tar.gz ]
  then
    TAR_EXT=.tar.gz
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  elif [ -f ${FULL_TARNAME}.tgz ]
  then
    TAR_EXT=.tgz
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  elif [ -f ${FULL_TARNAME}.tar.bz2 ]
  then
    TAR_EXT=.tar.bz2
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  elif [ -f ${FULL_TARNAME}.tbz ]
  then
    TAR_EXT=.tbz
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  elif [ -f ${FULL_TARNAME}.zip ]
  then
    TAR_EXT=.zip
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  elif [ -f ${FULL_TARNAME}.7z ]
  then
    TAR_EXT=.7z
    FULL_TARNAME=${FULL_TARNAME}${TAR_EXT}
  fi
fi

guess_tar_prog ${TAR_EXT}
}


pre_configure ()
{
rm -rf ${PKG}
mkdir -p ${PKG}
mkdir -p ${PKG}/usr/doc/$TARNAME-$VERSION
mkdir -p ${PKG}/install

CPUOPT="-mcpu"
GCCVER=`gcc -v 2>&1 > /dev/null | grep "gcc version" | sed -e "s/.*gcc version *//"`
case ${GCCVER} in
  3.4*|4.*) CPUOPT="-mtune" ;;
esac
}


fix_perms ()
{
chmod -R +X,o+w,go-w,a+r *

find . -perm 666 -exec chmod 644 {} \;
find . -perm 664 -exec chmod 644 {} \;
find . -perm 660 -exec chmod 644 {} \;
find . -perm 646 -exec chmod 644 {} \;
find . -perm 640 -exec chmod 644 {} \;
find . -perm 600 -exec chmod 644 {} \;
find . -perm 444 -exec chmod 644 {} \;
find . -perm 400 -exec chmod 644 {} \;
find . -perm 440 -exec chmod 644 {} \;
find . -perm 777 -exec chmod 755 {} \;
find . -perm 775 -exec chmod 755 {} \;
find . -perm 511 -exec chmod 755 {} \;
find . -perm 711 -exec chmod 755 {} \;
find . -perm 555 -exec chmod 755 {} \;
}

strip_binaries ()
{
( cd ${PKG}
  find . | xargs file | grep "executable" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
  find . | xargs file | grep "shared object" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
)
}

make_slack_desc()
{
cat > ${PKG}/install/slack-desc << EOF
# HOW TO EDIT THIS FILE:
# The "handy ruler" below makes it easier to edit a package description.  Line
# up the first '|' above the ':' following the base package name, and the '|'
# on the right side marks the last column you can put a character in.  You must
# make exactly 11 lines for the formatting to be correct.  It's also
# customary to leave one space after the ':'.

${PKGNAME//?/ }|-----handy-ruler------------------------------------------------------|
${PKGNAME}: ${PKGNAME} ${VERSION}
${PKGNAME}:
EOF

sed -e "s/^/${PKGNAME}: /" -e 's/ $//' >> ${PKG}/install/slack-desc
}

fix_links ()
{
# fix links
for f in `find ${PKG} -type l`
do
  if [[ `readlink ${f}` =~ "${PKG}.*" ]]
  then
    (cd `dirname ${f}`
     linkname=`basename ${f}`
     ln -snf `readlink ${linkname} | sed -e "s@${PKG}@@"` ${linkname}
    )
  fi
done
}

perllocalpod ()
{
(cd ${PKG}
 PERLLOCALPOD=`find . -name perllocal.pod`
 if [ -n "${PERLLOCALPOD}" ]; then
  echo WARNING --- perllocal.pod exists - renaming ...
  for f in ${PERLLOCALPOD}
  do
    (cd `dirname $f`
     mv perllocal.pod ${PKGNAME}.pod
    )
  done
 fi
)
}

compress_manpages ()
{
if [ -d ${PKG}/usr/share/man ]
then
  echo moving usr/share/man
  mkdir -p ${PKG}/usr/man
  for d in ${PKG}/usr/share/man/*
  do
    if [ -d ${PKG}/usr/man/${d##*/} ]
    then
      mv ${d}/* ${PKG}/usr/man/${d##*/}
      rmdir ${d}
    else
      mv ${d} ${PKG}/usr/man
    fi
  done
  rmdir ${PKG}/usr/share/man
fi

if [ -d ${PKG}/usr/man ]
then
  # compress man pages
  find ${PKG}/usr/man -exec gzip {} \;

  # make links point to right places
  for f in `find ${PKG}/usr/man -type l`
  do
    mv ${f} ${f}.gz
    ln -sf `readlink ${f}.gz`.gz ${f}.gz
  done
fi

if [ -d ${PKG}/usr/X11R6/man ]
then
  # compress man pages
  find ${PKG}/usr/X11R6/man -exec gzip {} \;

  # make links point to right places
  for f in `find ${PKG}/usr/X11R6/man -type l`
  do
    mv ${f} ${f}.gz
    ln -sf `readlink ${f}.gz`.gz ${f}.gz
  done
fi
}

compress_info ()
{
if [ -d ${PKG}/usr/share/info ]
then
  echo moving usr/share/info
  mv ${PKG}/usr/share/info ${PKG}/usr
fi

if [ -d ${PKG}/usr/info ]
then
  rm ${PKG}/usr/info/dir

  # compress info pages
  find ${PKG}/usr/info -exec gzip {} \;
fi
}


fix_docs ()
{
if [ -d ${PKG}/usr/share/doc/${TARNAME}-${VERSION} ]
then
  mv -f ${PKG}/usr/share/doc/${TARNAME}-${VERSION}/* ${PKG}/usr/doc/${TARNAME}-${VERSION}
  rm -rf ${PKG}/usr/share/doc
fi

if [ -d ${PKG}/usr/share/doc/${TARNAME} ]
then
  mv -f ${PKG}/usr/share/doc/${TARNAME}/* ${PKG}/usr/doc/${TARNAME}-${VERSION}
  rm -rf ${PKG}/usr/share/doc
fi

if [ -d ${PKG}/usr/share/doc/${PKGNAME} ]
then
  mv -f ${PKG}/usr/share/doc/${PKGNAME}/* ${PKG}/usr/doc/${TARNAME}-${VERSION}
  rm -rf ${PKG}/usr/share/doc
fi

if [ -d ${PKG}/usr/doc/${TARNAME} ]
then
  mv -f ${PKG}/usr/doc/${TARNAME}/* ${PKG}/usr/doc/${TARNAME}-${VERSION}
  rm -rf ${PKG}/usr/doc/${TARNAME}
fi

}


post_install ()
{
##############################################################
# if info dir exists, do install-info
#
if [ -d ${PKG}/usr/info ]
then
  infos=`ls ${PKG}/usr/info | grep \.info\.gz | tr '\012' ' '`
  if [ -n "${infos}" ]
  then
    cat <<EOF >> ${PKG}/install/doinst.sh
#
for n in ${infos}
do
  install-info --info-dir=/usr/info /usr/info/\${n}
done
EOF
  fi
fi

##############################################################
# if gconf schemas exist, run gconftool
#
if [ -d ${PKG}/etc/gconf/schemas ]
then
  schemas=`ls ${PKG}/etc/gconf/schemas | tr '\012' ' '`
  if [ -n "${schemas}" ]
  then
    cat <<EOF >> ${PKG}/install/doinst.sh
#
for n in ${schemas}
do
  GCONF_CONFIG_SOURCE=xml:merged:/etc/gconf/gconf.xml.defaults /usr/bin/gconftool-2 --makefile-install-rule /etc/gconf/schemas/\${n}
done
EOF
  fi
fi

##############################################################
# if usr/share/applications exists, run update-desktop-database
#
if [ -d ${PKG}/usr/share/applications ]
then
  cat <<EOF >> ${PKG}/install/doinst.sh
#
/usr/bin/update-desktop-database
EOF
fi

##############################################################
# if usr/share/mime exists, run update-mime-database
#
if [ -d ${PKG}/usr/share/mime ]
then
  cat <<EOF >> ${PKG}/install/doinst.sh
#
/usr/bin/update-mime-database /usr/share/mime
EOF
fi

##############################################################
# if usr/share/icons exists, run gtk-update-icon-cache
#
if [ -d ${PKG}/usr/share/icons ]
then
  icons=`find ${PKG}/usr/share/icons -type d -maxdepth 1 | grep -v "^${PKG}/usr/share/icons$" | sed -e 's@/.*/usr/share/icons/@@' | tr '\012' ' '`
  if [ -n "${icons}" ]
  then
    cat <<EOF >> ${PKG}/install/doinst.sh
#
for n in ${icons}
do
  gtk-update-icon-cache -f -t /usr/share/icons/\${n}
done
EOF
  fi
fi

##############################################################
# if var/lib/scrollkeeper or usr/share/omf exist, run
# scrollkeeper-update
#
if [ -d ${PKG}/var/lib/scrollkeeper -o -d ${PKG}/usr/share/omf ]
then
  if [ -d ${PKG}/var/lib/scrollkeeper ]
  then
    ( cd ${PKG}/var/lib/scrollkeeper && rm -r * )
  fi

  cat <<EOF >> ${PKG}/install/doinst.sh
#
if [ -x /usr/bin/scrollkeeper-update ]; then
  /usr/bin/scrollkeeper-update -p /var/lib/scrollkeeper 1> /dev/null 2> /dev/null
fi
EOF
fi

##############################################################
# if usr/lib/gtk-2.0/*/loaders exists, run
# gdk-pixbuf-query-loaders
#
if [ -d ${PKG}/usr/lib/gtk-2.0/*/loaders ]
then
  cat <<EOF >> ${PKG}/install/doinst.sh
#
if [ -x /usr/bin/gdk-pixbuf-query-loaders ]; then
  gdk-pixbuf-query-loaders > /etc/gtk-2.0/gdk-pixbuf.loaders
fi
EOF
fi

##############################################################
# if usr/lib/gtk-2.0/*/immodule exists, run
# gtk-query-immodules-2.0
#
if [ -d ${PKG}/usr/lib/gtk-2.0/*/immodule ]
then
  cat <<EOF >> ${PKG}/install/doinst.sh
#
if [ -x /usr/bin/gtk-query-immodules-2.0 ]; then
  gtk-query-immodules-2.0 > /etc/gtk-2.0/gtk.immodules
fi
EOF
fi

##############################################################
# warn if usr/local exists
#
if [ -d ${PKG}/usr/local ]
then
  echo WARNING --- usr/local directory exists
fi

if [ -d ${PKG}/usr/share/doc ]
then
  echo WARNING --- usr/share/doc directory exists
fi

if [ -d ${PKG}/tmp ]
then
  echo WARNING --- tmp directory exists
fi

if [ -d ${PKG}/home ]
then
  echo WARNING --- home directory exists
fi

if [ -d ${PKG}/usr/lib/pkgconfig ]
then
  if grep /usr/X11 ${PKG}/usr/lib/pkgconfig/*pc 2>&1 > /dev/null
  then
    echo WARNING --- pkgconfig files contain reference to /usr/X11
  fi
  if grep /home/ ${PKG}/usr/lib/pkgconfig/*pc 2>&1 > /dev/null
  then
    echo WARNING --- pkgconfig files contain reference to /home
  fi
fi

perllocalpod

}


doinst_config()
{
if ! grep -q "^config() {$" ${PKG}/install/doinst.sh
then
  cat << EOF >> ${PKG}/install/doinst.sh
#
config() {
  NEW="\$1"
  OLD="\`dirname \$NEW\`/\`basename \$NEW .new\`"
  # If there's no config file by that name, mv it over:
  if [ ! -r \$OLD ]; then
    mv \$NEW \$OLD
  elif [ "\`cat \$OLD | md5sum\`" = "\`cat \$NEW | md5sum\`" ]; then # toss the redundant copy
    rm \$NEW
  fi
  # Otherwise, we leave the .new copy for the admin to consider...
}

EOF
  WRITTEN_CONFIG=yes
fi

for n in $*
do
  echo config ${n} >> ${PKG}/install/doinst.sh
done
}


doinst_addgrp()
{
if [ "x$1" == "x" ]
then
  echo "*** doinst_addgrp() requires group argument"
  return
fi

cat << EOF >> ${PKG}/install/doinst.sh
###
# Create $1 group if doesn't exist.
###
group_exists=\`grep ^$1 etc/group\`
if [[ "\${group_exists}" == "" ]]; then
        groupadd $1
fi

EOF
}

doinst_addusergrp()
{
if [ "x$2" == "x" ]
then
  echo "*** doinst_addusergrp() requires user and group argument"
  return
fi

cat << EOF >> ${PKG}/install/doinst.sh
###
# Create $1 user in $2 group if they don't exist.
###
group_exists=\`grep ^$2 etc/group\`
if [[ "\${group_exists}" == "" ]]; then
        groupadd $2
fi
user_exists=\`grep ^$1 etc/passwd\`
if [[ "\${user_exists}" == "" ]]; then
        useradd $1 -g $2
fi

EOF
}

