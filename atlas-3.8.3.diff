--- atlas-3.8.3/src/blas/gemm/ATL_gereal2cplx.c.orig	2009-02-18 18:47:44.000000000 +0000
+++ atlas-3.8.3/src/blas/gemm/ATL_gereal2cplx.c	2009-04-10 16:28:52.000000000 +0100
@@ -43,7 +43,53 @@
    const int ldc2 = (ldc-M)<<1;
    int i, j;
 
-   if (ialp == ATL_rzero && ibet == ATL_rzero)
+/*
+ * Cannot read C if BETA is 0
+ */
+   if (rbet == ATL_rzero && ibet == ATL_rzero)
+   {
+      if (ialp == ATL_rzero)  /* alpha is a real number */
+      {
+         if (ralp == ATL_rone) /* alpha = 1.0 */
+         {
+            for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
+            {
+               for (i=0; i < M; i++, C += 2)
+               {
+                  *C = R[i];
+                  C[1] = I[i];
+               }
+            }
+         }
+         else
+         {
+            for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
+            {
+               for (i=0; i < M; i++, C += 2)
+               {
+                  *C = ralp * R[i];
+                  C[1] = ralp * I[i];
+               }
+            }
+         }
+      }
+      else                   /* alpha is a complex number */
+      {
+         for (j=0; j < N; j++, R += ldr, I += ldi, C += ldc2)
+         {
+            for (i=0; i < M; i++, C += 2)
+            {
+               ra = R[i]; ia = I[i];
+               C[0] = ralp * ra - ialp * ia;
+               C[1] = ralp * ia + ialp * ra;
+            }
+         }
+      }
+   }
+/*
+ * If alpha and beta are both real numbers
+ */
+   else if (ialp == ATL_rzero && ibet == ATL_rzero)
    {
       if (ralp == ATL_rone && rbet == ATL_rone)
       {
--- atlas-3.8.3/src/blas/gemm/ATL_cmmJITcp.c.orig	2009-02-18 18:47:44.000000000 +0000
+++ atlas-3.8.3/src/blas/gemm/ATL_cmmJITcp.c	2010-11-28 10:10:21.000000000 +0000
@@ -268,7 +268,7 @@
    {
       NBmm0 = NBmm1 = NBmmX = Mjoin(PATLU,pKBmm);
       if (SCALAR_IS_ZERO(beta))
-         Mjoin(PATL,gezero)(M, N, C, ldc);
+         { Mjoin(PATLU,gezero)(M, N, pC, ldpc); Mjoin(PATLU,gezero)(M, N, pC+ipc, ldpc); }
    }
    if (nblk)
    {
--- atlas-3.8.3/tune/blas/level1/scalsrch.c.orig	2009-02-18 18:48:25.000000000 +0000
+++ atlas-3.8.3/tune/blas/level1/scalsrch.c	2010-11-28 10:28:43.000000000 +0000
@@ -747,7 +747,7 @@
 /*
  * Handle all special alpha cases
  */
-   fprintf(fpout, "%sif ( SCALAR_IS_ZERO(alpha) )\n", spc);
+/*   fprintf(fpout, "%sif ( SCALAR_IS_ZERO(alpha) )\n", spc);
    fprintf(fpout, "%s{\n", spc);
    if (pre == 'c' || pre == 'z')
    {
@@ -756,7 +756,7 @@
    }
    else fprintf(fpout, "%s   Mjoin(PATL,set)(N, ATL_rzero, X, incx);\n", spc);
    fprintf(fpout, "%s   return;\n", spc);
-   fprintf(fpout, "%s}\n", spc);
+   fprintf(fpout, "%s}\n", spc); */
    GenAlphCase(pre, spc, fpout, 1, n, ix, iy, ia, ib);
    GenAlphCase(pre, spc, fpout, -1, n, ix, iy, ia, ib);
    if (pre == 'c' || pre == 'z')
--- atlas-3.8.3/tune/blas/gemm/CASES/ATL_smm14x1x84_sseCU.c.orig	2009-02-18 18:48:26.000000000 +0000
+++ atlas-3.8.3/tune/blas/gemm/CASES/ATL_smm14x1x84_sseCU.c	2010-11-28 10:08:49.000000000 +0000
@@ -46,6 +46,12 @@
 #if !defined(KB) || (KB == 0)
    #error "KB must be a compile-time constant!"
 #endif
+#if KB > 84
+   #error "KB cannot exceed 84!"
+#endif
+#if (KB/4)*4 != KB
+   #error "KB must be a multiple of 4!"
+#endif
 #if (MB/14)*14 != MB
    #error "MB must be multiple of 14!"
 #endif
--- atlas-3.8.3/tune/blas/gemm/emit_mm.c.orig	2009-02-18 18:48:25.000000000 +0000
+++ atlas-3.8.3/tune/blas/gemm/emit_mm.c	2010-04-19 23:19:20.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- *             Automatically Tuned Linear Algebra Software v3.8.3
+ *             Automatically Tuned Linear Algebra Software v3.8.4
  *                    (C) Copyright 1997 R. Clint Whaley
  *
  * Redistribution and use in source and binary forms, with or without
@@ -1638,7 +1638,7 @@
            cTA, cTB, M, N, K);
    fprintf(fpout, " * lda=%d, ldb=%d, ldc=%d, mu=%d, nu=%d, ku=%d, pf=%d\n",
            lda, ldb, ldc, mu, nu, ku, pfA);
-   fprintf(fpout, " * Generated by ATLAS/tune/blas/gemm/emit_mm.c (3.8.3)\n");
+   fprintf(fpout, " * Generated by ATLAS/tune/blas/gemm/emit_mm.c (3.8.4)\n");
    fprintf(fpout, " */\n");
 }
 
@@ -3082,7 +3082,17 @@
  * Returns 1 if nb is handled by succeeding case, 0 otherwise
  */
 {
-   for (; cp; cp = cp->next) if (nb % cp->imult == 0) return(1);
+
+   for (; cp; cp = cp->next)
+   {
+      if (cp->fixed == 2)
+      {
+         if (cp->imult == nb)
+            return(1);
+      }
+      else if (nb % cp->imult == 0)
+         return(1);
+   }
    return(0);
 }
 
@@ -3110,14 +3120,6 @@
       istop = cp0->nb;
       while (istop % cp0->imult) istop--;
       if (istop == cp0->nb) istop -= cp0->imult;
-      for (cp=cp0->next; cp; cp = cp->next)
-      {
-         if (cp->imult % cp0->imult == 0 && cp->fixed != 2)
-         {
-            istop = cp->imult;
-            break;
-         }
-      }
 
       for (i=2*cp0->imult; i <= istop; i += cp0->imult)
       {
@@ -3582,7 +3584,7 @@
    CLEANNODE *wp, *cp0;
    FILE *fp;
    int i;
-   const char *ifs = "else if", *ifp;
+   const char *ifs = "else if", *ifp, *sp;
    const char cwh[3] = {'M', 'N', 'K'};
    char ln[128], st[2], *typ;
 
@@ -3613,7 +3615,11 @@
 
    if (pre == 'c') pre = 'C';
    else if (pre == 'z') pre = 'Z';
-
+/*
+ * fixed=2 means a kernel specialized for that exact N.  They will have not
+ * survived pruning if they weren't better than all the general algorithms,
+ * so we can test for them all up front
+ */
    for (cp=cp0; cp; cp = cp->next)  /* handle fixed = 2 cases */
    {
       if (cp->fixed == 2)
@@ -3625,36 +3631,49 @@
          ifp = ifs;
       }
    }
-
-   for (cp=cp0; cp; cp = cp->next)  /* fixed = 1 cases */
-   {
-      if (cp->fixed == 1)
-      {
-         for (i=cp->ncomps-1; i >= 0; i--)
-         {
-            if (cp->imult > 1)
-               fprintf(fp, "   %s (%c == %d)\n", ifp, cwh[which], cp->NBs[i]);
-            else fprintf(fp, "   else\n");
-            fprintf(fp, "   {\n      ATL_%cup%cBmm%d_%d_%d_b%c%s;\n   }\n",
-                    pre, cwh[which], cp->NBs[i], cp->imult, cp->fixed,
-                    cbeta, MMARGS);
-            ifp = ifs;
-         }
-      }
-   }
-   for (cp=cp0; cp; cp = cp->next)  /* fixed = 0 cases */
-   {
+/*
+ * All remaining kernels are selected by being a multiple of imult;
+ * fixed=0 will be called directly, while fixed=1 will have a nested
+ * if to find the right compiled version to call
+ */
+   for (cp=cp0; cp; cp = cp->next)  /* fixed = 0/1 cases */
+   {
+      if (cp->fixed != 1 && cp->fixed != 0)
+         continue;
+      if (cp->imult > 1)
+         fprintf(fp, "   %s (%c == %s)\n", ifp, cwh[which],
+                 GetInc(cp->imult, GetDiv(cp->imult, st)));
+      else if (ifp == ifs) fprintf(fp, "   else\n");
       if (cp->fixed == 0)
       {
-         if (cp->imult > 1)
-            fprintf(fp, "   %s (%c == %s)\n", ifp, cwh[which],
-                    GetInc(cp->imult, GetDiv(cp->imult, st)));
-         else if (ifp == ifs) fprintf(fp, "   else\n");
          fprintf(fp, "   {\n      ATL_%cup%cBmm0_%d_%d_b%c%s;\n   }\n",
                  pre, cwh[which], cp->imult, cp->fixed, cbeta, MMARGS);
          ifp = ifs;
       }
+      else if (cp->fixed == 1)
+      {
+         fprintf(fp, "   {\n");
+         if (cp->ncomps == 1)
+            fprintf(fp, "      ATL_%cup%cBmm%d_%d_%d_b%c%s;\n",
+                    pre, cwh[which], cp->NBs[0], cp->imult, cp->fixed,
+                    cbeta, MMARGS);
+         else  /* must select kernel by NB[i] */
+         {
+            sp = "if";
+            for (i=cp->ncomps-1; i >= 0; i--)
+            {
+               fprintf(fp, "      %s (%c == %d)\n", sp, cwh[which], cp->NBs[i]);
+               fprintf(fp,
+               "      {\n         ATL_%cup%cBmm%d_%d_%d_b%c%s;\n      }\n",
+                       pre, cwh[which], cp->NBs[i], cp->imult, cp->fixed,
+                       cbeta, MMARGS);
+               sp = "else if";
+            }
+         }
+         fprintf(fp, "   }\n");
+      }
    }
+
    for (cp=cp0; cp && cp->imult != 1; cp = cp->next);
    if (!cp)
    {
@@ -4330,3 +4349,5 @@
    }
    exit(0);
 }
+
+ 	  	 
--- atlas-3.8.3/CONFIG/src/backend/archinfo_x86.c.orig	2009-02-18 18:47:37.000000000 +0000
+++ atlas-3.8.3/CONFIG/src/backend/archinfo_x86.c	2010-11-28 12:39:55.000000000 +0000
@@ -321,6 +321,7 @@
          break;
       case 3:
       case 4:
+      case 6:
          iret = IntP4E;
          break;
       default:
--- atlas-3.8.3/makes/Make.lib.orig	2009-02-18 18:47:36.000000000 +0000
+++ atlas-3.8.3/makes/Make.lib	2011-02-11 20:28:26.000000000 +0000
@@ -50,7 +50,7 @@
         --whole-archive libatlas.a --no-whole-archive -lc $(LIBS)
 liblapack.so : liblapack.a
 	ld $(LDFLAGS) -shared -soname $@ -o $@ --whole-archive \
-           liblapack.a --no-whole-archive $(F77SYSLIB)
+           liblapack.a --no-whole-archive $(F77SYSLIB) -lgcc
 libclapack.so : libclapack.a
 	ld $(LDFLAGS) -shared -soname liblapack.so -o liblapack.so \
            --whole-archive libclapack.a
