--- xf86-video-ati-6.6.192/src/r128.h.orig	2007-11-18 21:58:08.000000000 +0000
+++ xf86-video-ati-6.6.192/src/r128.h	2007-11-18 21:58:15.000000000 +0000
@@ -425,9 +425,32 @@
     Bool              DMAForXv;
 #endif
 
+                                /* XVideo */
     XF86VideoAdaptorPtr adaptor;
     void              (*VideoTimerCallback)(ScrnInfoPtr, Time);
     int               videoKey;
+    int		      RageTheatreCrystal;
+    int               RageTheatreTunerPort;
+    int               RageTheatreCompositePort;
+    int               RageTheatreSVideoPort;
+    int               tunerType;
+    Bool	      forceI2CProbing;
+    Bool               MM_TABLE_valid;
+    struct {
+    	CARD8 table_revision;
+	CARD8 table_size;
+        CARD8 tuner_type;
+        CARD8 audio_chip;
+        CARD8 product_id;
+        CARD8 tuner_voltage_teletext_fm;
+        CARD8 i2s_config; /* configuration of the sound chip */
+        CARD8 video_decoder_type;
+        CARD8 video_decoder_host_config;
+        CARD8 input[5];
+    	} MM_TABLE;
+    CARD16 video_decoder_type;
+    
+                                /* general */
     Bool              showCache;
     OptionInfoPtr     Options;
 
@@ -471,6 +494,11 @@
 extern int         R128MinBits(int val);
 
 extern void        R128InitVideo(ScreenPtr pScreen);
+#ifdef XvExtension
+extern void	   R128ShutdownVideo(ScrnInfoPtr pScrn);
+extern void        R128LeaveVT_Video(ScrnInfoPtr pScrn);
+extern void        R128EnterVT_Video(ScrnInfoPtr pScrn);
+#endif
 
 #ifdef XF86DRI
 extern Bool        R128DRIScreenInit(ScreenPtr pScreen);
--- xf86-video-ati-6.6.192/src/r128_driver.c.orig	2007-05-08 15:24:25.000000000 +0100
+++ xf86-video-ati-6.6.192/src/r128_driver.c	2007-11-18 21:58:26.000000000 +0000
@@ -149,7 +149,15 @@
   OPTION_PANEL_HEIGHT,
   OPTION_PROG_FP_REGS,
   OPTION_FBDEV,
+#ifdef XvExtension
   OPTION_VIDEO_KEY,
+  OPTION_RAGE_THEATRE_CRYSTAL,
+  OPTION_RAGE_THEATRE_TUNER_PORT,
+  OPTION_RAGE_THEATRE_COMPOSITE_PORT,
+  OPTION_RAGE_THEATRE_SVIDEO_PORT,
+  OPTION_TUNER_TYPE,
+  OPTION_FORCE_I2C_PROBING,
+#endif
   OPTION_SHOW_CACHE,
   OPTION_VGA_ACCESS
 } R128Opts;
@@ -176,7 +184,15 @@
   { OPTION_PANEL_HEIGHT, "PanelHeight",      OPTV_INTEGER, {0}, FALSE },
   { OPTION_PROG_FP_REGS, "ProgramFPRegs",    OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_FBDEV,        "UseFBDev",         OPTV_BOOLEAN, {0}, FALSE },
-  { OPTION_VIDEO_KEY,    "VideoKey",         OPTV_INTEGER, {0}, FALSE },
+#ifdef XvExtension
+  { OPTION_VIDEO_KEY,                   "VideoKey",                 OPTV_INTEGER, {0}, FALSE },
+  { OPTION_RAGE_THEATRE_CRYSTAL,        "RageTheatreCrystal",       OPTV_INTEGER, {0}, FALSE },
+  { OPTION_RAGE_THEATRE_TUNER_PORT,     "RageTheatreTunerPort",     OPTV_INTEGER, {0}, FALSE },
+  { OPTION_RAGE_THEATRE_COMPOSITE_PORT, "RageTheatreCompositePort", OPTV_INTEGER, {0}, FALSE },
+  { OPTION_RAGE_THEATRE_SVIDEO_PORT,    "RageTheatreSVideoPort",    OPTV_INTEGER, {0}, FALSE },
+  { OPTION_TUNER_TYPE,                  "TunerType",                OPTV_INTEGER, {0}, FALSE },
+  { OPTION_FORCE_I2C_PROBING, "ForceI2CProbing", OPTV_BOOLEAN, {0}, FALSE},
+#endif
   { OPTION_SHOW_CACHE,   "ShowCache",        OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_VGA_ACCESS,   "VGAAccess",        OPTV_BOOLEAN, {0}, TRUE  },
   { -1,                  NULL,               OPTV_NONE,    {0}, FALSE }
@@ -2032,6 +2048,71 @@
 }
 #endif
 
+static Bool R128PreInitXv(ScrnInfoPtr pScrn)
+{
+    R128InfoPtr  info = R128PTR(pScrn);
+    CARD16 mm_table;
+    CARD16 bios_header;
+    CARD16 pll_info_block;
+
+    /* Rescue MM_TABLE before VBIOS is freed */
+    info->MM_TABLE_valid = FALSE;
+    
+    if((info->VBIOS==NULL)||(info->VBIOS[0]!=0x55)||(info->VBIOS[1]!=0xaa)){
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Cannot access BIOS or it is not valid.\n"
+               "\t\tIf your card is TV-in capable you will need to specify options RageTheatreCrystal, RageTheatreTunerPort, \n"
+               "\t\tRageTheatreSVideoPort and TunerType in /etc/X11/xorg.conf.\n"
+               );
+       info->MM_TABLE_valid = FALSE;
+       return TRUE;
+       }
+
+    bios_header=info->VBIOS[0x48];
+    bios_header+=(((int)info->VBIOS[0x49]+0)<<8);           
+        
+    mm_table=info->VBIOS[bios_header+0x38];
+    if(mm_table==0)
+    {
+        xf86DrvMsg(pScrn->scrnIndex,X_INFO,"No MM_TABLE found - assuming CARD is not TV-in capable.\n");
+        info->MM_TABLE_valid = FALSE;
+        return TRUE;
+    }
+    mm_table+=(((int)info->VBIOS[bios_header+0x39]+0)<<8)-2;
+    
+    if(mm_table>0)
+    {
+        memcpy(&(info->MM_TABLE), &(info->VBIOS[mm_table]), sizeof(info->MM_TABLE));
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MM_TABLE: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n",
+            info->MM_TABLE.table_revision,
+            info->MM_TABLE.table_size,
+            info->MM_TABLE.tuner_type,
+            info->MM_TABLE.audio_chip,
+            info->MM_TABLE.product_id,
+            info->MM_TABLE.tuner_voltage_teletext_fm,
+            info->MM_TABLE.i2s_config,
+            info->MM_TABLE.video_decoder_type,
+            info->MM_TABLE.video_decoder_host_config,
+            info->MM_TABLE.input[0],
+            info->MM_TABLE.input[1],
+            info->MM_TABLE.input[2],
+            info->MM_TABLE.input[3],
+            info->MM_TABLE.input[4]);
+        info->MM_TABLE_valid = TRUE;
+    } else {
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No MM_TABLE found - assuming card is not TV-in capable (mm_table=%d).\n", mm_table);
+        info->MM_TABLE_valid = FALSE;
+    }
+
+    pll_info_block=info->VBIOS[bios_header+0x30];
+    pll_info_block+=(((int)info->VBIOS[bios_header+0x31]+0)<<8);
+       
+    info->video_decoder_type=info->VBIOS[pll_info_block+0x08];
+    info->video_decoder_type+=(((int)info->VBIOS[pll_info_block+0x09]+0)<<8);
+    
+    return TRUE;
+}
+
+
 static void
 R128ProbeDDC(ScrnInfoPtr pScrn, int indx)
 {
@@ -2160,12 +2241,75 @@
 
     if (!R128PreInitWeight(pScrn))    goto fail;
 
+#ifdef XvExtension
     if(xf86GetOptValInteger(info->Options, OPTION_VIDEO_KEY, &(info->videoKey))) {
         xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
                                 info->videoKey);
     } else {
         info->videoKey = 0x1E;
     }
+    if(xf86GetOptValInteger(info->Options, OPTION_RAGE_THEATRE_CRYSTAL, &(info->RageTheatreCrystal))) {
+        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rage Theatre Crystal frequency was specified as %d.%d Mhz\n",
+                                info->RageTheatreCrystal/100, info->RageTheatreCrystal % 100);
+    } else {
+    	info->RageTheatreCrystal=-1;
+    }
+
+    if(xf86GetOptValInteger(info->Options, OPTION_RAGE_THEATRE_TUNER_PORT, &(info->RageTheatreTunerPort))) {
+        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rage Theatre tuner port was specified as %d\n",
+                                info->RageTheatreTunerPort);
+    } else {
+    	info->RageTheatreTunerPort=-1;
+    }
+    
+    if(info->RageTheatreTunerPort>5){
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Attempt to assign Rage Theatre tuner port to invalid value. Disabling setting\n");
+	 info->RageTheatreTunerPort=-1;
+	 }
+
+    if(xf86GetOptValInteger(info->Options, OPTION_RAGE_THEATRE_COMPOSITE_PORT, &(info->RageTheatreCompositePort))) {
+        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rage Theatre composite port was specified as %d\n",
+                                info->RageTheatreCompositePort);
+    } else {
+    	info->RageTheatreCompositePort=-1;
+    }
+
+    if(info->RageTheatreCompositePort>6){
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Attempt to assign Rage Theatre composite port to invalid value. Disabling setting\n");
+	 info->RageTheatreCompositePort=-1;
+	 }
+
+    if(xf86GetOptValInteger(info->Options, OPTION_RAGE_THEATRE_SVIDEO_PORT, &(info->RageTheatreSVideoPort))) {
+        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Rage Theatre SVideo Port was specified as %d\n",
+                                info->RageTheatreSVideoPort);
+    } else {
+    	info->RageTheatreSVideoPort=-1;
+    }
+
+    if(info->RageTheatreSVideoPort>6){
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Attempt to assign Rage Theatre SVideo port to invalid value. Disabling setting\n");
+	 info->RageTheatreSVideoPort=-1;
+	 }
+
+    if(xf86GetOptValInteger(info->Options, OPTION_TUNER_TYPE, &(info->tunerType))) {
+        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Tuner type was specified as %d\n",
+                                info->tunerType);
+    } else {
+    	info->tunerType=-1;
+    }
+
+    if(info->tunerType>31){
+         xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Attempt to set tuner type to invalid value. Disabling setting\n");
+	 info->tunerType=-1;
+	 }
+
+    if(xf86ReturnOptValBool(info->Options, OPTION_FORCE_I2C_PROBING, FALSE)) {
+       info->forceI2CProbing=TRUE;
+       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forcing probing of multimedia I2C bus\n");
+    } else {
+       info->forceI2CProbing=FALSE;
+    }
+#endif
 
     if (xf86ReturnOptValBool(info->Options, OPTION_SHOW_CACHE, FALSE)) {
         info->showCache = TRUE;
@@ -2217,6 +2361,8 @@
     if (!R128PreInitDRI(pScrn))                goto fail;
 #endif
 
+    if (!R128PreInitXv(pScrn))                 goto fail;
+
 				/* Free the video bios (if applicable) */
     if (info->VBIOS) {
 	xfree(info->VBIOS);
@@ -3643,6 +3789,10 @@
     }
 #endif
 
+#ifdef XvExtension
+    R128EnterVT_Video(pScrn);
+#endif
+
     return TRUE;
 }
 
@@ -4403,6 +4553,11 @@
     R128SavePtr save  = &info->ModeReg;
 
     R128TRACE(("R128LeaveVT\n"));
+
+#ifdef XvExtension
+    R128LeaveVT_Video(pScrn);
+#endif
+
 #ifdef XF86DRI
     if (info->directRenderingEnabled) {
 	DRILock(pScrn->pScreen, 0);
--- xf86-video-ati-6.6.192/src/r128_reg.h.orig	2007-04-27 04:20:11.000000000 +0100
+++ xf86-video-ati-6.6.192/src/r128_reg.h	2007-11-18 21:58:43.000000000 +0000
@@ -274,8 +274,6 @@
 
 #define R128_CACHE_CNTL                   0x1724
 #define R128_CACHE_LINE                   0x0f0c /* PCI */
-#define R128_CAP0_TRIG_CNTL               0x0950 /* ? */
-#define R128_CAP1_TRIG_CNTL               0x09c0 /* ? */
 #define R128_CAPABILITIES_ID              0x0f50 /* PCI */
 #define R128_CAPABILITIES_PTR             0x0f34 /* PCI */
 #define R128_CLK_PIN_CNTL                 0x0001 /* PLL */
@@ -712,7 +710,10 @@
 #define R128_HW_DEBUG                     0x0128
 #define R128_HW_DEBUG2                    0x011c
 
-#define R128_I2C_CNTL_1                   0x0094 /* ? */
+#define R128_I2C_CNTL_0			  0x0090
+#define R128_I2C_CNTL_1                   0x0094
+#define R128_I2C_DATA			  0x0098
+
 #define R128_INTERRUPT_LINE               0x0f3c /* PCI */
 #define R128_INTERRUPT_PIN                0x0f3d /* PCI */
 #define R128_IO_BASE                      0x0f14 /* PCI */
@@ -841,6 +842,16 @@
 #define R128_OV0_VID_BUF_PITCH0_VALUE     0x0460
 #define R128_OV0_VID_BUF_PITCH1_VALUE     0x0464
 #define R128_OV0_AUTO_FLIP_CNTL           0x0470
+#       define  R128_OV0_AUTO_FLIP_CNTL_SOFT_BUF_NUM        0x00000007
+#       define  R128_OV0_AUTO_FLIP_CNTL_SOFT_REPEAT_FIELD   0x00000008
+#       define  R128_OV0_AUTO_FLIP_CNTL_SOFT_BUF_ODD        0x00000010
+#       define  R128_OV0_AUTO_FLIP_CNTL_IGNORE_REPEAT_FIELD 0x00000020
+#       define  R128_OV0_AUTO_FLIP_CNTL_SOFT_EOF_TOGGLE     0x00000040
+#       define  R128_OV0_AUTO_FLIP_CNTL_VID_PORT_SELECT     0x00000300
+#       define  R128_OV0_AUTO_FLIP_CNTL_P1_FIRST_LINE_EVEN  0x00010000
+#       define  R128_OV0_AUTO_FLIP_CNTL_SHIFT_EVEN_DOWN     0x00040000
+#       define  R128_OV0_AUTO_FLIP_CNTL_SHIFT_ODD_DOWN      0x00080000
+#       define  R128_OV0_AUTO_FLIP_CNTL_FIELD_POL_SOURCE    0x00800000
 #define R128_OV0_DEINTERLACE_PATTERN      0x0474
 #define R128_OV0_H_INC                    0x0480
 #define R128_OV0_STEP_BY                  0x0484
@@ -876,6 +887,96 @@
 #       define  R128_CMP_MIX_AND                 0x00000100L
 #define R128_OV0_TEST                     0x04F8
 
+/* first capture unit */
+
+#define R128_CAP0_BUF0_OFFSET	 	  0x0920
+#define R128_CAP0_BUF1_OFFSET	 	  0x0924
+#define R128_CAP0_BUF0_EVEN_OFFSET	  0x0928
+#define R128_CAP0_BUF1_EVEN_OFFSET	  0x092C
+
+#define R128_CAP0_BUF_PITCH		  0x0930
+#define R128_CAP0_V_WINDOW		  0x0934
+#define R128_CAP0_H_WINDOW		  0x0938
+#define R128_CAP0_VBI_ODD_OFFSET	  0x093C
+#define R128_CAP0_VBI_EVEN_OFFSET	  0x0940
+#define R128_CAP0_VBI_V_WINDOW		  0x0944
+#define R128_CAP0_VBI_H_WINDOW		  0x0948
+#define R128_CAP0_PORT_MODE_CNTL	  0x094C
+#define R128_CAP0_TRIG_CNTL               0x0950 
+#       define R128_CAP0_TRIG_CNTL_TRIGGER_GET         0x00000003        
+#       define R128_CAP0_TRIG_CNTL_TRIGGER_SET         0x00000001        
+#       define R128_CAP0_TRIG_CNTL_CAPTURE_EN          0x00000010        
+#       define R128_CAP0_TRIG_CNTL_VSYNC_GET           0x0000FF00        
+#       define R128_CAP0_TRIG_CNTL_VSYNC_SET           0x00010000        
+#define R128_CAP0_DEBUG			  0x0954
+#define R128_CAP0_CONFIG		  0x0958
+#       define R128_CAP0_CONFIG_CONTINUOS          0x00000001
+#       define R128_CAP0_CONFIG_START_FIELD_EVEN   0x00000002
+#       define R128_CAP0_CONFIG_START_BUF_GET      0x00000004
+#       define R128_CAP0_CONFIG_START_BUF_SET      0x00000008
+#       define R128_CAP0_CONFIG_BUF_TYPE_ALT       0x00000010
+#       define R128_CAP0_CONFIG_BUF_TYPE_FRAME     0x00000020
+#       define R128_CAP0_CONFIG_ONESHOT_MODE_FRAME 0x00000040
+#       define R128_CAP0_CONFIG_BUF_MODE_DOUBLE    0x00000080
+#       define R128_CAP0_CONFIG_BUF_MODE_TRIPLE    0x00000100
+#       define R128_CAP0_CONFIG_MIRROR_EN          0x00000200
+#       define R128_CAP0_CONFIG_ONESHOT_MIRROR_EN  0x00000400
+#       define R128_CAP0_CONFIG_VIDEO_SIGNED_UV    0x00000800
+#       define R128_CAP0_CONFIG_ANC_DECODE_EN      0x00001000
+#       define R128_CAP0_CONFIG_VBI_EN             0x00002000
+#       define R128_CAP0_CONFIG_SOFT_PULL_DOWN_EN  0x00004000
+#       define R128_CAP0_CONFIG_VIP_EXTEND_FLAG_EN 0x00008000
+#       define R128_CAP0_CONFIG_FAKE_FIELD_EN      0x00010000
+#       define R128_CAP0_CONFIG_ODD_ONE_MORE_LINE  0x00020000
+#       define R128_CAP0_CONFIG_EVEN_ONE_MORE_LINE 0x00040000
+#       define R128_CAP0_CONFIG_HORZ_DIVIDE_2      0x00080000
+#       define R128_CAP0_CONFIG_HORZ_DIVIDE_4      0x00100000
+#       define R128_CAP0_CONFIG_VERT_DIVIDE_2      0x00200000
+#       define R128_CAP0_CONFIG_VERT_DIVIDE_4      0x00400000
+#       define R128_CAP0_CONFIG_FORMAT_BROOKTREE   0x00000000
+#       define R128_CAP0_CONFIG_FORMAT_CCIR656     0x00800000
+#       define R128_CAP0_CONFIG_FORMAT_ZV          0x01000000
+#       define R128_CAP0_CONFIG_FORMAT_VIP         0x01800000
+#       define R128_CAP0_CONFIG_FORMAT_TRANSPORT   0x02000000
+#       define R128_CAP0_CONFIG_HORZ_DECIMATOR     0x04000000
+#       define R128_CAP0_CONFIG_VIDEO_IN_YVYU422   0x00000000
+#       define R128_CAP0_CONFIG_VIDEO_IN_VYUY422   0x20000000
+#define R128_CAP0_ANC_ODD_OFFSET	  0x095C
+#define R128_CAP0_ANC_EVEN_OFFSET	  0x0960
+#define R128_CAP0_ANC_H_WINDOW		  0x0964
+#define R128_CAP0_VIDEO_SYNC_TEST	  0x0968
+#define R128_CAP0_ONESHOT_BUF_OFFSET	  0x096C
+#define R128_CAP0_BUF_STATUS		  0x0970
+#define R128_CAP0_DWNSC_XRATIO	 	  0x0978
+#define R128_CAP0_XSHARPNESS		  0x097C
+
+/* second capture unit */
+
+#define R128_CAP1_BUF0_OFFSET	 	  0x0990
+#define R128_CAP1_BUF1_OFFSET	 	  0x0994
+#define R128_CAP1_BUF0_EVEN_OFFSET	  0x0998
+#define R128_CAP1_BUF1_EVEN_OFFSET	  0x099C
+
+#define R128_CAP1_BUF_PITCH		  0x09A0
+#define R128_CAP1_V_WINDOW		  0x09A4
+#define R128_CAP1_H_WINDOW		  0x09A8
+#define R128_CAP1_VBI_ODD_OFFSET	  0x09AC
+#define R128_CAP1_VBI_EVEN_OFFSET	  0x09B0
+#define R128_CAP1_VBI_V_WINDOW		  0x09B4
+#define R128_CAP1_VBI_H_WINDOW		  0x09B8
+#define R128_CAP1_PORT_MODE_CNTL	  0x09BC
+#define R128_CAP1_TRIG_CNTL		  0x09C0
+#define R128_CAP1_DEBUG			  0x09C4
+#define R128_CAP1_CONFIG		  0x09C8
+#define R128_CAP1_ANC_ODD_OFFSET	  0x09CC
+#define R128_CAP1_ANC_EVEN_OFFSET	  0x09D0
+#define R128_CAP1_ANC_H_WINDOW		  0x09D4
+#define R128_CAP1_VIDEO_SYNC_TEST	  0x09D8
+#define R128_CAP1_ONESHOT_BUF_OFFSET	  0x09DC
+#define R128_CAP1_BUF_STATUS		  0x09E0
+#define R128_CAP1_DWNSC_XRATIO	 	  0x09E8
+#define R128_CAP1_XSHARPNESS		  0x09EC
+
 
 #define R128_PALETTE_DATA                 0x00b4
 #define R128_PALETTE_INDEX                0x00b0
@@ -974,6 +1075,8 @@
 #define R128_SW_SEMAPHORE                 0x013c
 
 #define R128_TEST_DEBUG_CNTL              0x0120
+#define R128_TEST_DEBUG_CNTL__TEST_DEBUG_OUT_EN 0x00000001
+
 #define R128_TEST_DEBUG_MUX               0x0124
 #define R128_TEST_DEBUG_OUT               0x012c
 #define R128_TMDS_CRC                     0x02a0
@@ -1000,7 +1103,18 @@
 #define R128_VGA_DDA_ON_OFF               0x02ec
 #define R128_VID_BUFFER_CONTROL           0x0900
 #define R128_VIDEOMUX_CNTL                0x0190
-#define R128_VIPH_CONTROL                 0x01D0 /* ? */
+/* #define R128_VIPH_CONTROL                 0x01D0  */
+#define R128_VIPH_CONTROL                 0x0c40
+#define R128_VIPH_DV_LAT                  0x0c44
+#define R128_VIPH_BM_CHUNK                0x0c48
+#define R128_VIPH_DV_INT                  0x0c4c
+#define R128_VIPH_TIMEOUT_STAT            0x0c50
+#define R128_VIPH_TIMEOUT_STAT__VIPH_REG_STAT 0x00000010
+#define R128_VIPH_TIMEOUT_STAT__VIPH_REG_AK   0x00000010
+#define R128_VIPH_TIMEOUT_STAT__VIPH_REGR_DIS 0x01000000
+
+#define R128_VIPH_REG_DATA                0x0084
+#define R128_VIPH_REG_ADDR                0x0080
 
 #define R128_WAIT_UNTIL                   0x1720
 
--- xf86-video-ati-6.6.192/src/r128_video.c.orig	2007-04-27 04:20:11.000000000 +0100
+++ xf86-video-ati-6.6.192/src/r128_video.c	2007-11-18 21:58:57.000000000 +0000
@@ -7,6 +7,7 @@
 
 #include "r128.h"
 #include "r128_reg.h"
+#include "r128_video.h"
 
 #ifdef XF86DRI
 #include "r128_common.h"
@@ -19,6 +20,8 @@
 #include <X11/extensions/Xv.h>
 #include "fourcc.h"
 
+#include "theatre_reg.h"
+
 #define OFF_DELAY       250  /* milliseconds */
 #define FREE_DELAY      15000
 
@@ -40,6 +43,13 @@
 static int  R128QueryImageAttributes(ScrnInfoPtr, int, unsigned short *,
 			unsigned short *,  int *, int *);
 
+static void R128_BT_SetEncoding(R128PortPrivPtr pPriv);
+static void R128_RT_SetEncoding(R128PortPrivPtr pPriv);
+static void R128_MSP_SetEncoding(R128PortPrivPtr pPriv);
+
+static int R128PutVideo(ScrnInfoPtr pScrn, short src_x, short src_y, short drw_x, short drw_y,
+                        short src_w, short src_h, short drw_w, short drw_h, 
+			RegionPtr clipBoxes, pointer data);
 
 static void R128ResetVideo(ScrnInfoPtr);
 
@@ -48,22 +58,12 @@
 
 #define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
 
-static Atom xvBrightness, xvColorKey, xvSaturation, xvDoubleBuffer;
+static Atom xvBrightness, xvColorKey, xvSaturation, xvColor, xvDoubleBuffer, 
+          xvEncoding, xvVolume, xvMute, xvFrequency, xvContrast, xvHue,
+	  xv_autopaint_colorkey, xv_set_defaults, xvTunerStatus, xvSAP,
+	     xvLocationID, xvDeviceID, xvInstanceID;
 
 
-typedef struct {
-   int           brightness;
-   int           saturation;
-   Bool          doubleBuffer;
-   unsigned char currentBuffer;
-   FBLinearPtr   linear;
-   RegionRec     clip;
-   CARD32        colorKey;
-   CARD32        videoStatus;
-   Time          offTime;
-   Time          freeTime;
-   int           ecp_div;
-} R128PortPrivRec, *R128PortPrivPtr;
 
 static void R128ECP(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
 {
@@ -125,6 +125,29 @@
    {1, 1}
 };
 
+ /* the picture is interlaced - hence the half-heights */
+
+static XF86VideoEncodingRec
+InputVideoEncodings[] =
+{
+    { 0, "XV_IMAGE",			2048,2048,{1,1}},        
+    { 1, "pal-composite",		720, 288, { 1, 50 }},
+    { 2, "pal-tuner",			720, 288, { 1, 50 }},
+    { 3, "pal-svideo",			720, 288, { 1, 50 }},
+    { 4, "ntsc-composite",		640, 240, { 1001, 60000 }},
+    { 5, "ntsc-tuner",			640, 240, { 1001, 60000 }},
+    { 6, "ntsc-svideo",			640, 240, { 1001, 60000 }},
+    { 7, "secam-composite",		720, 288, { 1, 50 }},
+    { 8, "secam-tuner",			720, 288, { 1, 50 }},
+    { 9, "secam-svideo",		720, 288, { 1, 50 }},
+    { 10,"pal_60-composite",		768, 288, { 1, 50 }},
+    { 11,"pal_60-tuner",		768, 288, { 1, 50 }},
+    { 12,"pal_60-svideo",		768, 288, { 1, 50 }},
+    { 13, "pal_m-composite",           640, 240, { 1001, 60000 }},
+    { 14, "pal_m-tuner",               640, 240, { 1001, 60000 }},
+    { 15, "pal_m-svideo",              640, 240, { 1001, 60000 }}
+};
+
 #define NUM_FORMATS 12
 
 static XF86VideoFormatRec Formats[NUM_FORMATS] =
@@ -136,14 +159,30 @@
 };
 
 
-#define NUM_ATTRIBUTES 4
+#define NUM_ATTRIBUTES 12
+#define NUM_DEC_ATTRIBUTES (NUM_ATTRIBUTES+6)
 
-static XF86AttributeRec Attributes[NUM_ATTRIBUTES] =
+static XF86AttributeRec Attributes[NUM_DEC_ATTRIBUTES] =
 {
+   {             XvGettable, 0, ~0, "XV_DEVICE_ID"},
+   {             XvGettable, 0, ~0, "XV_LOCATION_ID"},
+   {             XvGettable, 0, ~0, "XV_INSTANCE_ID"},
+   {XvSettable             , 0, 1, "XV_SET_DEFAULTS"},
+   {XvSettable | XvGettable, 0, 1, "XV_AUTOPAINT_COLORKEY"},
    {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
-   {XvSettable | XvGettable, -64, 63, "XV_BRIGHTNESS"},
-   {XvSettable | XvGettable, 0, 31, "XV_SATURATION"},
-   {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"}
+   {XvSettable | XvGettable, -1000, 1000, "XV_BRIGHTNESS"},
+   {XvSettable | XvGettable, -1000, 1000, "XV_CONTRAST"},
+   {XvSettable | XvGettable, -1000, 1000, "XV_SATURATION"},
+   {XvSettable | XvGettable, -1000, 1000, "XV_COLOR"},
+   {XvSettable | XvGettable, -1000, 1000, "XV_HUE"},
+   {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"},
+        /* attributes published when decoder is onboard */
+   {XvSettable | XvGettable, 0, 12, "XV_ENCODING"},
+   {XvSettable | XvGettable, 0, -1, "XV_FREQ"},
+   {XvGettable, -1000, 1000, "XV_TUNER_STATUS"},
+   {XvSettable | XvGettable, 0, 1, "XV_MUTE"},
+   {XvSettable | XvGettable, 0, 1, "XV_SAP" },
+   {XvSettable | XvGettable, -1000, 1000, "XV_VOLUME"}
 };
 
 #define NUM_IMAGES 4
@@ -162,8 +201,37 @@
     R128InfoPtr   info      = R128PTR(pScrn);
     unsigned char *R128MMIO = info->MMIO;
     R128PortPrivPtr pPriv = info->adaptor->pPortPrivates[0].ptr;
+    char tmp[200];
 
 
+    xvBrightness   = MAKE_ATOM("XV_BRIGHTNESS");
+    xvSaturation   = MAKE_ATOM("XV_SATURATION");
+    xvColor        = MAKE_ATOM("XV_COLOR");
+    xvContrast     = MAKE_ATOM("XV_CONTRAST");
+    xvColorKey     = MAKE_ATOM("XV_COLORKEY");
+    xvDoubleBuffer = MAKE_ATOM("XV_DOUBLE_BUFFER");
+    xvEncoding     = MAKE_ATOM("XV_ENCODING");
+    xvTunerStatus  = MAKE_ATOM("XV_TUNER_STATUS");
+    xvFrequency    = MAKE_ATOM("XV_FREQ");
+    xvVolume       = MAKE_ATOM("XV_VOLUME");
+    xvMute         = MAKE_ATOM("XV_MUTE");
+    xvSAP          = MAKE_ATOM("XV_SAP");
+    xvHue          = MAKE_ATOM("XV_HUE");
+    xv_autopaint_colorkey = MAKE_ATOM("XV_AUTOPAINT_COLORKEY");
+    xv_set_defaults = MAKE_ATOM("XV_SET_DEFAULTS");
+
+    xvInstanceID = MAKE_ATOM("XV_INSTANCE_ID");
+    xvDeviceID = MAKE_ATOM("XV_DEVICE_ID");
+    xvLocationID = MAKE_ATOM("XV_LOCATION_ID");
+    
+    sprintf(tmp, "RXXX:%d.%d.%d", info->PciInfo->vendor, info->PciInfo->chipType, info->PciInfo->chipRev);
+    pPriv->device_id = MAKE_ATOM(tmp);
+    sprintf(tmp, "PCI:%02d:%02d.%d", info->PciInfo->bus, info->PciInfo->device, info->PciInfo->func);
+    pPriv->location_id = MAKE_ATOM(tmp);
+    sprintf(tmp, "INSTANCE:%d", pScrn->scrnIndex);
+    pPriv->instance_id = MAKE_ATOM(tmp);
+
+    R128WaitForFifo(pScrn, 11); 
     OUTREG(R128_OV0_SCALE_CNTL, 0x80000000);
     OUTREG(R128_OV0_EXCLUSIVE_HORZ, 0);
     OUTREG(R128_OV0_AUTO_FLIP_CNTL, 0);   /* maybe */
@@ -175,8 +243,160 @@
     OUTREG(R128_OV0_GRAPHICS_KEY_CLR, pPriv->colorKey);
     OUTREG(R128_OV0_KEY_CNTL, R128_GRAPHIC_KEY_FN_NE);
     OUTREG(R128_OV0_TEST, 0);
+    OUTPLL(R128_FCP_CNTL, 0x404);
+    OUTREG(R128_CAP0_TRIG_CNTL, 0x0);
+    
+    if(pPriv->VIP!=NULL){
+    	R128VIP_init(pScrn, pPriv);
+	}
+    
+    if(pPriv->theatre != NULL){
+    	xf86_InitTheatre(pPriv->theatre);
+	}
+}
+
+void R128LeaveVT_Video(ScrnInfoPtr pScrn)
+{
+    R128InfoPtr   info      = R128PTR(pScrn);
+    R128PortPrivPtr pPriv;
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Shutting down Xvideo subsystems\n");
+
+    if(info->adaptor==NULL)return;
+    pPriv = info->adaptor->pPortPrivates[0].ptr;
+    R128ResetVideo(pScrn);
+    if(pPriv==NULL)return;
+    if(pPriv->theatre!=NULL){
+    	xf86_ShutdownTheatre(pPriv->theatre);
+	}
+}
+
+void R128EnterVT_Video(ScrnInfoPtr pScrn)
+{
+    R128InfoPtr   info      = R128PTR(pScrn);
+    R128PortPrivPtr pPriv;
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Starting up Xvideo subsystems\n");
+    if(info->adaptor==NULL)return;
+    pPriv = info->adaptor->pPortPrivates[0].ptr;
+    if(pPriv==NULL)return;
+    R128ResetVideo(pScrn);
 }
 
+void R128ShutdownVideo(ScrnInfoPtr pScrn)
+{
+    R128InfoPtr   info      = R128PTR(pScrn);
+    R128PortPrivPtr pPriv = info->adaptor->pPortPrivates[0].ptr;
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "** Shutting down Xvideo subsystems\n");
+    if(pPriv->theatre!=NULL){
+	xf86_ShutdownTheatre(pPriv->theatre);
+	}
+    if(pPriv->i2c!=NULL){
+	if(pPriv->msp3430!=NULL){
+		xfree(pPriv->msp3430);
+		pPriv->msp3430=NULL;
+		}
+	if(pPriv->fi1236!=NULL){
+		xfree(pPriv->fi1236);
+		pPriv->fi1236=NULL;
+		}
+	if(pPriv->bt829!=NULL){
+		xfree(pPriv->bt829);
+		pPriv->bt829=NULL;
+		}
+	if(pPriv->tda9850!=NULL){
+		xfree(pPriv->tda9850);
+		pPriv->tda9850=NULL;
+		}
+	if(pPriv->tda8425!=NULL){
+		xfree(pPriv->tda8425);
+		pPriv->tda8425=NULL;
+		}
+	DestroyI2CBusRec(pPriv->i2c, TRUE, TRUE);
+	pPriv->i2c=NULL;
+	}
+    if(pPriv->VIP!=NULL){
+	xfree(pPriv->VIP);
+	pPriv->VIP=NULL;
+	}
+    if(pPriv->theatre!=NULL){
+	xfree(pPriv->theatre);
+	pPriv->theatre=NULL;
+	}
+}
+
+
+static Bool R128SetupTheatre(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv, TheatrePtr t)
+{
+    R128InfoPtr info = R128PTR(pScrn);
+    R128PLLPtr  pll = &(info->pll);
+
+    CARD8 a;
+    int i;
+	
+    if(!info->MM_TABLE_valid && 
+       !((info->RageTheatreCrystal>=0) &&
+           (info->RageTheatreTunerPort>=0) && (info->RageTheatreCompositePort>=0) &&
+           (info->RageTheatreSVideoPort>=0)))
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no multimedia table present, disabling Rage Theatre.\n");
+       return FALSE;
+    }
+
+     t->video_decoder_type=info->video_decoder_type;
+	
+    if(info->MM_TABLE_valid){
+        for(i=0;i<5;i++){
+		a=info->MM_TABLE.input[i];
+		
+		switch(a & 0x3){
+			case 1:
+				t->wTunerConnector=i;
+				xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"Tuner is on port %d\n",i);
+				break;
+			case 2:  if(a & 0x4){
+				   t->wComp0Connector=RT_COMP2;
+				   } else {
+				   t->wComp0Connector=RT_COMP1;
+				   }
+				xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"Composite connector is port %d\n",t->wComp0Connector);
+				  break;
+			case 3:  if(a & 0x4){
+				   t->wSVideo0Connector=RT_YCR_COMP4;
+				   } else {
+				   t->wSVideo0Connector=RT_YCF_COMP4;
+				   }
+				xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"SVideo connector is port %d\n",t->wSVideo0Connector);
+				   break;
+			default:
+				break;
+			}
+		}
+
+	xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"Rage Theatre: Connectors (detected): tuner=%d, composite=%d, svideo=%d\n",t->wTunerConnector, t->wComp0Connector, t->wSVideo0Connector);
+        }
+	
+    if(info->RageTheatreTunerPort>=0)t->wTunerConnector=info->RageTheatreTunerPort;
+    if(info->RageTheatreCompositePort>=0)t->wComp0Connector=info->RageTheatreCompositePort;
+    if(info->RageTheatreSVideoPort>=0)t->wSVideo0Connector=info->RageTheatreSVideoPort;
+	
+    xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"Rage Theatre: Connectors (using): tuner=%d, composite=%d, svideo=%d\n",t->wTunerConnector, t->wComp0Connector, t->wSVideo0Connector);
+
+    switch((info->RageTheatreCrystal>=0)?info->RageTheatreCrystal:pll->reference_freq){
+    	case 2700:
+    		t->video_decoder_type=RT_FREF_2700;
+    		break;
+    	case 2950:
+    		t->video_decoder_type=RT_FREF_2950;
+    		break;
+    	default:
+    		xf86DrvMsg(t->VIP->scrnIndex,X_INFO,
+    			"Unsupported reference clock frequency, Rage Theatre disabled\n");
+    		t->theatre_num=-1;
+    		return FALSE;
+    	}
+    xf86DrvMsg(t->VIP->scrnIndex,X_INFO,"video decoder type used: 0x%04x\n",t->video_decoder_type);
+    return TRUE;
+}
 
 static XF86VideoAdaptorPtr
 R128AllocAdaptor(ScrnInfoPtr pScrn)
@@ -207,7 +427,20 @@
     pPriv->videoStatus = 0;
     pPriv->brightness = 0;
     pPriv->saturation = 16;
+    pPriv->contrast = 0;
+    pPriv->hue = 0;
     pPriv->currentBuffer = 0;
+    
+    
+    pPriv->video_stream_active = FALSE;
+    pPriv->encoding = 1;
+    pPriv->frequency = 1000;
+    pPriv->volume = -1000;
+    pPriv->mute = TRUE;
+    pPriv->v=0;
+
+    pPriv->autopaint_colorkey = TRUE;
+    
     R128ECP(pScrn, pPriv);
 
     return adapt;
@@ -221,22 +454,92 @@
     R128PortPrivPtr pPriv;
     XF86VideoAdaptorPtr adapt;
 
+    info->accel->Sync(pScrn);
+
+      /* do not leak memory and structures on X server restarts */
+    if(info->adaptor != NULL){
+    	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reinitializing Xvideo subsystems\n");
+	R128ResetVideo(pScrn);
+	return info->adaptor;
+	}
+
     if(!(adapt = R128AllocAdaptor(pScrn)))
 	return NULL;
 
+    pPriv = (R128PortPrivPtr)(adapt->pPortPrivates[0].ptr);
+
+    R128InitI2C(pScrn,pPriv);
+
+    if(!info->MM_TABLE_valid && 
+       !((info->RageTheatreCrystal>=0) &&
+           (info->RageTheatreTunerPort>=0) && (info->RageTheatreCompositePort>=0) &&
+           (info->RageTheatreSVideoPort>=0)))
+      {
+     	xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Skipping Rage Theatre detection because of absent or invalid MM_TABLE\n");
+	pPriv->theatre=NULL;
+      } else      
+    if(pPriv->bt829 == NULL){
+    
+    
+      R128VIP_init(pScrn,pPriv);
+
+      if(!xf86LoadSubModule(pScrn,"theatre")) 
+      {
+     	xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Unable to load Rage Theatre module\n");
+	pPriv->theatre=NULL;
+      } else 
+      {
+        xf86LoaderReqSymbols(TheatreSymbolsList, NULL);
+        pPriv->theatre=xf86_DetectTheatre(pPriv->VIP);
+        if((pPriv->theatre != NULL) && !R128SetupTheatre(pScrn, pPriv, pPriv->theatre))
+        {
+    	  free(pPriv->theatre);
+	  pPriv->theatre=NULL;
+	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to initialize Rage Theatre, chip disabled\n");
+        }
+       
+        if(pPriv->theatre != NULL) {
+          xf86_InitTheatre(pPriv->theatre);
+        }
+      }
+    }
+
+    R128InitI2CAudio(pScrn,pPriv);
+
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
     adapt->name = "ATI Rage128 Video Overlay";
-    adapt->nEncodings = 1;
-    adapt->pEncodings = &DummyEncoding;
+       if(pPriv->theatre != NULL)
+       {
+          adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
+          adapt->nEncodings = 13;
+          adapt->pEncodings = InputVideoEncodings;
+       } else 
+       if(pPriv->bt829 != NULL)
+       {
+          adapt->type = XvWindowMask | XvInputMask | XvImageMask | XvVideoMask;
+          adapt->nEncodings = 16;
+	  adapt->pEncodings = InputVideoEncodings;
+       } else
+       {
+          adapt->type = XvWindowMask | XvInputMask | XvImageMask;
+          adapt->nEncodings = 1;
+          adapt->pEncodings =  &DummyEncoding;
+       }
     adapt->nFormats = NUM_FORMATS;
     adapt->pFormats = Formats;
     adapt->nPorts = 1;
-    adapt->nAttributes = NUM_ATTRIBUTES;
+       if(pPriv->msp3430!=NULL)
+	       adapt->nAttributes = NUM_DEC_ATTRIBUTES;
+	       else 
+       if((pPriv->theatre!=NULL)||(pPriv->bt829!=NULL))
+	       adapt->nAttributes = NUM_DEC_ATTRIBUTES-1;  /* MSP chip not detected => thus no volume control */
+	       else 
+	       adapt->nAttributes =  NUM_ATTRIBUTES;
     adapt->pAttributes = Attributes;
     adapt->nImages = NUM_IMAGES;
     adapt->pImages = Images;
-    adapt->PutVideo = NULL;
+    adapt->PutVideo = R128PutVideo;
     adapt->PutStill = NULL;
     adapt->GetVideo = NULL;
     adapt->GetStill = NULL;
@@ -249,7 +552,6 @@
 
     info->adaptor = adapt;
 
-    pPriv = (R128PortPrivPtr)(adapt->pPortPrivates[0].ptr);
     REGION_NULL(pScreen, &(pPriv->clip));
 
     R128ResetVideo(pScrn);
@@ -270,6 +572,15 @@
      if(pPriv->videoStatus & CLIENT_VIDEO_ON) {
 	OUTREG(R128_OV0_SCALE_CNTL, 0);
      }
+     if(pPriv->video_stream_active) {
+	R128WaitForFifo(pScrn, 8); 
+        OUTPLL(R128_FCP_CNTL, 0x404);
+        OUTREG(R128_CAP0_TRIG_CNTL, 0x0);
+	R128ResetVideo(pScrn);
+	pPriv->video_stream_active = FALSE;
+        R128MuteAudio(pPriv, TRUE);
+        if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
+     }
      if(pPriv->linear) {
 	xf86FreeOffscreenLinear(pPriv->linear);
 	pPriv->linear = NULL;
@@ -293,24 +604,61 @@
   R128InfoPtr info = R128PTR(pScrn);
   unsigned char *R128MMIO = info->MMIO;
   R128PortPrivPtr pPriv = (R128PortPrivPtr)data;
+  Bool save_mute;
+
+  info->accel->Sync(pScrn);
 
+  if(attribute == xv_autopaint_colorkey) {
+  	pPriv->autopaint_colorkey = value;
+  } else
+  if(attribute == xv_set_defaults) {
+        R128SetPortAttribute(pScrn, xv_autopaint_colorkey, TRUE, data);
+        R128SetPortAttribute(pScrn, xvBrightness, 0, data);
+        R128SetPortAttribute(pScrn, xvSaturation, 0, data);
+        R128SetPortAttribute(pScrn, xvContrast,   0, data);
+        R128SetPortAttribute(pScrn, xvHue,   0, data);
+        R128SetPortAttribute(pScrn, xvVolume,   0, data);
+        R128SetPortAttribute(pScrn, xvMute,   1, data);
+        R128SetPortAttribute(pScrn, xvSAP,   0, data);
+        R128SetPortAttribute(pScrn, xvDoubleBuffer,   1, data);
+  } else
   if(attribute == xvBrightness) {
-	if((value < -64) || (value > 63))
-	   return BadValue;
+        /*  No reason to complain, just clip properly */
+        if(value < -1000)value = -1000;
+	if(value > 1000)value = 1000;
 	pPriv->brightness = value;
 
-	OUTREG(R128_OV0_COLOUR_CNTL, (pPriv->brightness & 0x7f) |
-				     (pPriv->saturation << 8) |
-				     (pPriv->saturation << 16));
+	R128WaitForFifo(pScrn, 2);
+	OUTREG(R128_OV0_COLOUR_CNTL, (((pPriv->brightness*64)/1000) & 0x7f) |
+				     (((pPriv->saturation*31+31000)/2000) << 8) |
+				     (((pPriv->saturation*31+31000)/2000) << 16));
+	if(pPriv->theatre!=NULL) xf86_RT_SetBrightness(pPriv->theatre, pPriv->brightness);	
+	if(pPriv->bt829!=NULL) xf86_bt829_SetBrightness(pPriv->bt829, pPriv->brightness);	
   } else
-  if(attribute == xvSaturation) {
-	if((value < 0) || (value > 31))
-	   return BadValue;
+  if(attribute == xvSaturation || (attribute == xvColor)) {
+        if(value < -1000)value = -1000;
+	if(value > 1000)value = 1000;
 	pPriv->saturation = value;
-
-	OUTREG(R128_OV0_COLOUR_CNTL, (pPriv->brightness & 0x7f) |
-				     (pPriv->saturation << 8) |
-				     (pPriv->saturation << 16));
+	R128WaitForFifo(pScrn, 1);
+	OUTREG(R128_OV0_COLOUR_CNTL, (((pPriv->brightness*64)/1000) & 0x7f) |
+				     (((pPriv->saturation*31+31000)/2000) << 8) |
+				     (((pPriv->saturation*31+31000)/2000) << 16));
+	if(pPriv->theatre != NULL)xf86_RT_SetSaturation(pPriv->theatre, value);
+	if(pPriv->bt829!=NULL) xf86_bt829_SetSaturation(pPriv->bt829, pPriv->saturation);	
+  } else
+  if(attribute == xvContrast) {
+        if(value < -1000)value = -1000;
+	if(value > 1000)value = 1000;
+	pPriv->contrast = value;
+	if(pPriv->theatre != NULL)xf86_RT_SetContrast(pPriv->theatre, value);
+	if(pPriv->bt829!=NULL) xf86_bt829_SetContrast(pPriv->bt829, pPriv->contrast);	
+  } else
+  if(attribute == xvHue) {
+        if(value < -1000)value = -1000;
+	if(value > 1000)value = 1000;
+	pPriv->hue = value;
+	if(pPriv->theatre != NULL)xf86_RT_SetTint(pPriv->theatre, value);
+	if(pPriv->bt829!=NULL) xf86_bt829_SetTint(pPriv->bt829, pPriv->hue);	
   } else
   if(attribute == xvDoubleBuffer) {
 	if((value < 0) || (value > 1))
@@ -322,6 +670,45 @@
 	OUTREG(R128_OV0_GRAPHICS_KEY_CLR, pPriv->colorKey);
 
 	REGION_EMPTY(pScrn->pScreen, &pPriv->clip);
+  } else 
+  if(attribute == xvEncoding) {
+	pPriv->encoding = value;
+	if(pPriv->video_stream_active)
+	{
+	   if(pPriv->theatre != NULL) R128_RT_SetEncoding(pPriv);
+	   if(pPriv->bt829 != NULL) R128_BT_SetEncoding(pPriv);
+	   if(pPriv->msp3430 != NULL) R128_MSP_SetEncoding(pPriv);
+           if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
+	/* put more here to actually change it */
+	}
+  } else 
+  if(attribute == xvFrequency) {
+        pPriv->frequency = value;
+	save_mute = pPriv->mute;
+	R128MuteAudio(pPriv, TRUE);
+  	if(pPriv->fi1236 != NULL) xf86_TUNER_set_frequency(pPriv->fi1236, value);
+	if((pPriv->msp3430 != NULL) && (pPriv->msp3430->recheck))
+		xf86_InitMSP3430(pPriv->msp3430);
+	R128MuteAudio(pPriv, save_mute);
+  } else 
+  if(attribute == xvMute) {
+        pPriv->mute = value;
+        R128MuteAudio(pPriv, pPriv->mute);
+        if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
+  } else 
+  if(attribute == xvSAP) {
+        pPriv->sap_channel = value;
+	if(pPriv->msp3430!=NULL)xf86_MSP3430SetSAP(pPriv->msp3430, pPriv->sap_channel?4:3);
+	if(pPriv->tda9850!=NULL)xf86_tda9850_sap_mute(pPriv->tda9850, pPriv->sap_channel?1:0);
+  } else 
+  if(attribute == xvVolume) {
+  	if(value<-1000) value=-1000;
+	if(value>1000) value=1000;
+        pPriv->volume = value;
+	pPriv->mute = FALSE;
+        if(pPriv->msp3430 != NULL) xf86_MSP3430SetVolume(pPriv->msp3430, MSP3430_VOLUME(value));
+        R128MuteAudio(pPriv, pPriv->mute);
+        if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
   } else return BadMatch;
 
   return Success;
@@ -336,17 +723,58 @@
 ){
   R128PortPrivPtr pPriv = (R128PortPrivPtr)data;
 
+  if(attribute == xv_autopaint_colorkey) {
+  	*value = pPriv->autopaint_colorkey;
+  } else
   if(attribute == xvBrightness) {
 	*value = pPriv->brightness;
   } else
-  if(attribute == xvSaturation) {
+  if((attribute == xvSaturation) || (attribute == xvColor)) {
 	*value = pPriv->saturation;
   } else
+  if(attribute == xvContrast) {
+	*value = pPriv->contrast;
+  } else
+  if(attribute == xvHue) {
+	*value = pPriv->hue;
+  } else
   if(attribute == xvDoubleBuffer) {
 	*value = pPriv->doubleBuffer ? 1 : 0;
   } else
   if(attribute == xvColorKey) {
 	*value = pPriv->colorKey;
+  } else 
+  if(attribute == xvEncoding) {
+	*value = pPriv->encoding;
+  } else 
+  if(attribute == xvFrequency) {
+        *value = pPriv->frequency;
+  } else 
+  if(attribute == xvTunerStatus) {
+  	if(pPriv->fi1236==NULL){
+		*value=TUNER_OFF;
+		} else
+		{
+	        *value = xf86_TUNER_get_afc_hint(pPriv->fi1236);
+		}
+  } else 
+  if(attribute == xvMute) {
+        *value = pPriv->mute;
+  } else 
+  if(attribute == xvSAP) {
+        *value = pPriv->sap_channel;
+  } else 
+  if(attribute == xvVolume) {
+        *value = pPriv->volume;
+  } else 
+  if(attribute == xvDeviceID) {
+        *value = pPriv->device_id;
+  } else 
+  if(attribute == xvLocationID) {
+        *value = pPriv->location_id;
+  } else 
+  if(attribute == xvInstanceID) {
+        *value = pPriv->instance_id;
   } else return BadMatch;
 
   return Success;
@@ -607,8 +1035,9 @@
 static void
 R128DisplayVideo422(
     ScrnInfoPtr pScrn,
+    R128PortPrivPtr pPriv,
     int id,
-    int offset,
+    int offset1, int offset2,
     short width, short height,
     int pitch,
     int left, int right, int top,
@@ -618,7 +1047,6 @@
 ){
     R128InfoPtr info = R128PTR(pScrn);
     unsigned char *R128MMIO = info->MMIO;
-    R128PortPrivPtr pPriv = info->adaptor->pPortPrivates[0].ptr;
     int v_inc, h_inc, step_by, tmp;
     int p1_h_accum_init, p23_h_accum_init;
     int p1_v_accum_init;
@@ -636,7 +1064,8 @@
 
     /* keep everything in 16.16 */
 
-    offset += ((left >> 16) & ~7) << 1;
+    offset1 += ((left >> 16) & ~7) << 1;
+    offset2 += ((left >> 16) & ~7) << 1;
 
     tmp = (left & 0x0003ffff) + 0x00028000 + (h_inc << 3);
     p1_h_accum_init = ((tmp <<  4) & 0x000f8000) |
@@ -665,16 +1094,35 @@
     left >>= 1; width >>= 1;
     OUTREG(R128_OV0_P2_X_START_END, (width - 1) | (left << 16));
     OUTREG(R128_OV0_P3_X_START_END, (width - 1) | (left << 16));
-    OUTREG(R128_OV0_VID_BUF0_BASE_ADRS, offset & 0xfffffff0);
+    
+    OUTREG(R128_OV0_VID_BUF1_BASE_ADRS, offset1 & 0xfffffff0);
+    OUTREG(R128_OV0_VID_BUF2_BASE_ADRS, offset1 & 0xfffffff0);
+
+    OUTREG(R128_OV0_VID_BUF3_BASE_ADRS, offset2 & 0xfffffff0);
+    OUTREG(R128_OV0_VID_BUF4_BASE_ADRS, offset2 & 0xfffffff0);
+    OUTREG(R128_OV0_VID_BUF5_BASE_ADRS, offset2 & 0xfffffff0);
+    
     OUTREG(R128_OV0_P1_V_ACCUM_INIT, p1_v_accum_init);
     OUTREG(R128_OV0_P23_V_ACCUM_INIT, 0);
     OUTREG(R128_OV0_P1_H_ACCUM_INIT, p1_h_accum_init);
     OUTREG(R128_OV0_P23_H_ACCUM_INIT, p23_h_accum_init);
 
     if(id == FOURCC_UYVY)
-       OUTREG(R128_OV0_SCALE_CNTL, 0x41FF8C03);
+       OUTREG(R128_OV0_SCALE_CNTL, R128_SCALER_PIX_EXPAND \
+	       | R128_SCALER_Y2R_TEMP \
+	       | R128_SCALER_SOURCE_YVYU422 \
+	       | R128_SCALER_SMART_SWITCH \
+	       | R128_SCALER_BURST_PER_PLANE \
+	       | R128_SCALER_DOUBLE_BUFFER \
+	       | R128_SCALER_ENABLE);
     else
-       OUTREG(R128_OV0_SCALE_CNTL, 0x41FF8B03);
+       OUTREG(R128_OV0_SCALE_CNTL, R128_SCALER_PIX_EXPAND \
+	       | R128_SCALER_Y2R_TEMP \
+	       | R128_SCALER_SOURCE_VYUY422 \
+	       | R128_SCALER_SMART_SWITCH \
+	       | R128_SCALER_BURST_PER_PLANE \
+	       | R128_SCALER_DOUBLE_BUFFER \
+	       | R128_SCALER_ENABLE);
 
     OUTREG(R128_OV0_REG_LOAD_CNTL, 0);
 }
@@ -824,7 +1272,13 @@
 
    if(!xf86XVClipVideoHelper(&dstBox, &xa, &xb, &ya, &yb,
 			     clipBoxes, width, height))
+	{
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+        /* restore byte swapping */
+        OUTREG(R128_CONFIG_CNTL, config_cntl);
+#endif
 	return Success;
+	}
 
    dstBox.x1 -= pScrn->frameX0;
    dstBox.x2 -= pScrn->frameX0;
@@ -942,7 +1396,7 @@
      case FOURCC_UYVY:
      case FOURCC_YUY2:
      default:
-	R128DisplayVideo422(pScrn, id, offset + d1line, width, height, dstPitch,
+	R128DisplayVideo422(pScrn, pPriv, id, offset + d1line, offset + d1line, width, height, dstPitch,
 		     xa, xb, ya, &dstBox, src_w, src_h, drw_w, drw_h);
 	break;
     }
@@ -997,6 +1451,457 @@
     return size;
 }
 
+static void R128_RT_SetEncoding(R128PortPrivPtr pPriv)
+{
+switch(pPriv->encoding){
+	case 1:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_COMPOSITE, 0);
+		pPriv->v=24;
+		break;
+	case 2:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_TUNER,0);
+		pPriv->v=24;
+		break;
+	case 3:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_SVIDEO,0);
+		pPriv->v=24;
+		break;
+	case 4:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_NTSC | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_COMPOSITE,0);
+		pPriv->v=23;
+		break;
+	case 5:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_NTSC | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_TUNER, 0);
+		pPriv->v=23;
+		break;
+	case 6:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_NTSC | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_SVIDEO, 0);
+		pPriv->v=23;
+		break;
+	case 7:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_SECAM | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_COMPOSITE, 0);
+		pPriv->v=25;
+		break;
+	case 8:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_SECAM | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_TUNER, 0);
+		pPriv->v=25;
+		break;
+	case 9:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_SECAM | extNONE);
+		xf86_RT_SetConnector(pPriv->theatre, DEC_SVIDEO, 0);
+		pPriv->v=25;
+		break;
+	case 10:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL_60);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_COMPOSITE, 0);
+		pPriv->v=24;
+		break;
+	case 11:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL_60);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_TUNER,0);
+		pPriv->v=24;
+		break;
+	case 12:
+		xf86_RT_SetStandard(pPriv->theatre,DEC_PAL | extPAL_60);
+		xf86_RT_SetConnector(pPriv->theatre,DEC_SVIDEO,0);
+		pPriv->v=24;
+		break;
+	default:
+	        pPriv->v=0;
+		return;
+	}	
+}
+
+
+
+static void R128_MSP_SetEncoding(R128PortPrivPtr pPriv)
+{
+xf86_MSP3430SetVolume(pPriv->msp3430, MSP3430_FAST_MUTE);
+switch(pPriv->encoding){
+	case 1:
+		pPriv->msp3430->standard = MSP3430_PAL;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
+		break;
+	case 2:
+		pPriv->msp3430->standard = MSP3430_PAL;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
+		break;
+	case 3:
+		pPriv->msp3430->standard = MSP3430_PAL;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
+		break;
+	case 4:
+		pPriv->msp3430->standard = MSP3430_NTSC;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
+		break;
+	case 5:
+		pPriv->msp3430->standard = MSP3430_NTSC;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
+		break;
+	case 6:
+		pPriv->msp3430->standard = MSP3430_NTSC;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
+		break;
+	case 7:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
+		break;
+	case 8:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
+		break;
+	case 9:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
+		break;
+	case 10:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_3;
+		break;
+	case 11:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_1;
+		break;
+	case 12:
+		pPriv->msp3430->standard = MSP3430_SECAM;
+		pPriv->msp3430->connector = MSP3430_CONNECTOR_2;
+		break;
+	default:
+		return;
+	}	
+xf86_InitMSP3430(pPriv->msp3430);
+xf86_MSP3430SetVolume(pPriv->msp3430, pPriv->mute ? MSP3430_FAST_MUTE : MSP3430_VOLUME(pPriv->volume));
+}
+
+static void R128_BT_SetEncoding(R128PortPrivPtr pPriv)
+{
+switch(pPriv->encoding){
+	case 1:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
+		pPriv->v=24;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
+		break;
+	case 2:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
+		pPriv->v=24;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
+		break;
+	case 3:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
+		pPriv->v=24;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL);
+		break;
+	case 4:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
+		pPriv->v=23;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
+		break;
+	case 5:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
+		pPriv->v=23;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
+		break;
+	case 6:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
+		pPriv->v=23;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
+		break;
+	case 7:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
+		pPriv->v=25;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
+		break;
+	case 8:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
+		pPriv->v=25;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
+		break;
+	case 9:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
+		pPriv->v=25;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_SECAM);
+		break;
+       case 13:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
+                pPriv->v=23;
+                xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL_M);
+                break;
+       case 14:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX0);
+                pPriv->v=23;
+                xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL_M);
+                break;
+       case 15:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX1);
+                pPriv->v=23;
+                xf86_bt829_SetFormat(pPriv->bt829, BT829_PAL_M);
+                break;
+	default:
+                xf86_bt829_SetMux(pPriv->bt829, BT829_MUX2);
+		pPriv->v=23;
+	        xf86_bt829_SetFormat(pPriv->bt829, BT829_NTSC);
+		return;
+	}	
+if(pPriv->tda9850!=NULL){
+	pPriv->tda9850->mux = pPriv->bt829->mux;
+	xf86_tda9850_setaudio(pPriv->tda9850);
+	}
+}
+
+/* capture config constants */
+#define BUF_TYPE_FIELD		0
+#define BUF_TYPE_ALTERNATING	1
+#define BUF_TYPE_FRAME		2
+
+
+#define BUF_MODE_SINGLE		0
+#define BUF_MODE_DOUBLE		1
+#define BUF_MODE_TRIPLE		2
+/* CAP0_CONFIG values */
+
+
+/* Older, original magic.. let's leave these for reference 
+#define ENABLE_R128_CAPTURE_WEAVE (0x1C000005L \
+		| (BUF_MODE_SINGLE <<7) \
+		| (BUF_TYPE_FRAME << 4) \
+		| ( (pPriv->theatre !=NULL)?(1L<<23):0) \
+		| (1<<29)) 
+#define ENABLE_R128_CAPTURE_BOB (0x1C000005L \
+		| (BUF_MODE_SINGLE <<7) \
+		| (BUF_TYPE_ALTERNATING << 4) \
+		| ( (pPriv->theatre !=NULL)?(1L<<23):0) \
+		| (0<<15) \
+		| (1<<29)) 
+
+*/
+
+#define ENABLE_R128_CAPTURE_WEAVE (R128_CAP0_CONFIG_CONTINUOS \
+			| (BUF_MODE_SINGLE <<7) \
+			| (BUF_TYPE_FRAME << 4) \
+			| ( (pPriv->theatre !=NULL) ? \
+				(R128_CAP0_CONFIG_FORMAT_CCIR656): \
+				(R128_CAP0_CONFIG_FORMAT_BROOKTREE)) \
+			| R128_CAP0_CONFIG_HORZ_DECIMATOR \
+			| R128_CAP0_CONFIG_VIDEO_IN_VYUY422)
+
+#define ENABLE_R128_CAPTURE_BOB (R128_CAP0_CONFIG_CONTINUOS \
+			| (BUF_MODE_SINGLE <<7)  \
+			| (BUF_TYPE_ALTERNATING << 4) \
+			| ( (pPriv->theatre !=NULL) ? \
+				(R128_CAP0_CONFIG_FORMAT_CCIR656): \
+				(R128_CAP0_CONFIG_FORMAT_BROOKTREE)) \
+			| R128_CAP0_CONFIG_HORZ_DECIMATOR \
+			| R128_CAP0_CONFIG_VIDEO_IN_VYUY422)
+
+static int
+R128PutVideo(
+  ScrnInfoPtr pScrn,
+  short src_x, short src_y,
+  short drw_x, short drw_y,
+  short src_w, short src_h,
+  short drw_w, short drw_h,
+  RegionPtr clipBoxes, pointer data
+){
+   R128InfoPtr info = R128PTR(pScrn);
+   R128PortPrivPtr pPriv = (R128PortPrivPtr)data;
+   unsigned char *R128MMIO = info->MMIO;
+   INT32 xa, xb, ya, yb, top;
+   int pitch, new_size, offset1, offset2, s2offset, s3offset;
+   int srcPitch, srcPitch2, dstPitch;
+   int bpp;
+   BoxRec dstBox;
+   CARD32 id;
+   int width, height;
+
+   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PutVideo\n");
+   info->accel->Sync(pScrn);
+   /*
+    * s2offset, s3offset - byte offsets into U and V plane of the
+    *                      source where copying starts.  Y plane is
+    *                      done by editing "buf".
+    *
+    * offset - byte offset to the first line of the destination.
+    *
+    * dst_start - byte address to the first displayed pel.
+    *
+    */
+
+   /* make the compiler happy */
+   s2offset = s3offset = srcPitch2 = 0;
+
+   if(src_w > (drw_w << 4))
+	drw_w = src_w >> 4;
+   if(src_h > (drw_h << 4))
+	drw_h = src_h >> 4;
+
+   /* Clip */
+   xa = src_x;
+   xb = src_x + src_w;
+   ya = src_y;
+   yb = src_y + src_h;
+
+   dstBox.x1 = drw_x;
+   dstBox.x2 = drw_x + drw_w;
+   dstBox.y1 = drw_y;
+   dstBox.y2 = drw_y + drw_h;
+
+   if(pPriv->theatre != NULL)
+   {
+      width = InputVideoEncodings[pPriv->encoding].width;
+      height = InputVideoEncodings[pPriv->encoding].height; 
+   } else 
+   if(pPriv->bt829 != NULL)
+   {
+      width = InputVideoEncodings[pPriv->encoding].width;
+      height = InputVideoEncodings[pPriv->encoding].height;
+   } else 
+      return FALSE;
+        
+   if(!xf86XVClipVideoHelper(&dstBox, &xa, &xb, &ya, &yb,
+			     clipBoxes, width, height))
+	return Success;
+
+   dstBox.x1 -= pScrn->frameX0;
+   dstBox.x2 -= pScrn->frameX0;
+   dstBox.y1 -= pScrn->frameY0;
+   dstBox.y2 -= pScrn->frameY0;
+
+   bpp = pScrn->bitsPerPixel >> 3;
+   pitch = bpp * pScrn->displayWidth;
+
+   id = FOURCC_YUY2;
+
+   top = ya>>16;
+
+   switch(id) {
+   case FOURCC_YV12:
+   case FOURCC_I420:
+   	top &= ~1;
+	dstPitch = ((width << 1) + 15) & ~15;
+	new_size = ((dstPitch * height) + bpp - 1) / bpp;
+	srcPitch = (width + 3) & ~3;
+	s2offset = srcPitch * height;
+	srcPitch2 = ((width >> 1) + 3) & ~3;
+	s3offset = (srcPitch2 * (height >> 1)) + s2offset;
+	break;
+   case FOURCC_UYVY:
+   case FOURCC_YUY2:
+   default:
+	dstPitch = ((width << 1) + 15) & ~15;
+	new_size = ((dstPitch * height) + bpp - 1) / bpp;
+	srcPitch = (width << 1);
+	break;
+   }
+
+   new_size += 0x1f;  /* for aligning */
+
+   if(!(pPriv->linear = R128AllocateMemory(pScrn, pPriv->linear, new_size*2)))
+   {
+	return BadAlloc;
+   }
+
+
+   R128WaitForFifo(pScrn, 14);
+
+   offset1 = (pPriv->linear->offset*bpp+0xf) & (~0xf);
+   offset2 = ((pPriv->linear->offset+new_size)*bpp + 0x1f) & (~0xf);
+   
+   OUTREG(R128_CAP0_BUF0_OFFSET, offset1);
+   OUTREG(R128_CAP0_BUF0_EVEN_OFFSET, offset2);
+   OUTREG(R128_CAP0_ONESHOT_BUF_OFFSET, offset1);
+   OUTREG(R128_CAP0_BUF1_OFFSET, offset1);
+   OUTREG(R128_CAP0_BUF1_EVEN_OFFSET, offset2);
+   
+   OUTREG(R128_CAP0_BUF_PITCH, width*2);
+   OUTREG(R128_CAP0_H_WINDOW, (2*width)<<16);
+   OUTREG(R128_CAP0_V_WINDOW, (((height)+pPriv->v-1)<<16)|(pPriv->v));
+   OUTREG(R128_OV0_AUTO_FLIP_CNTL, R128_OV0_AUTO_FLIP_CNTL_SOFT_BUF_ODD);
+   OUTREG(R128_CAP0_CONFIG, ENABLE_R128_CAPTURE_BOB);
+   OUTREG(R128_CAP0_DEBUG, 0);
+   
+   OUTREG(R128_CAP0_DWNSC_XRATIO, 0x10001000);
+   OUTREG(R128_CAP0_XSHARPNESS, 0);
+   OUTREG(R128_TEST_DEBUG_CNTL, 0);
+   
+   if(! pPriv->video_stream_active){
+
+   /* activate capture unit */
+   R128WaitForFifo(pScrn, 4);
+   
+   /* undocumented magic, note: these work.. unlike the values in ATI kit,
+      ATI has been notified.. */
+   OUTREG(R128_VIDEOMUX_CNTL, (INREG(R128_VIDEOMUX_CNTL)| 2 |1));
+
+   OUTREG(R128_CAP0_PORT_MODE_CNTL, (pPriv->theatre!=NULL)? 1: 0);
+   
+   OUTPLL(R128_FCP_CNTL, 0x101);
+
+   OUTREG(R128_CAP0_TRIG_CNTL, R128_CAP0_TRIG_CNTL_TRIGGER_SET | 
+                               R128_CAP0_TRIG_CNTL_CAPTURE_EN);
+   
+   
+   if(pPriv->theatre != NULL) 
+   {
+      xf86_RT_SetInterlace(pPriv->theatre, 1);
+      R128_RT_SetEncoding(pPriv);
+      xf86_RT_SetOutputVideoSize(pPriv->theatre, width, height*2, 0, 0);   
+   }
+   
+   if(pPriv->bt829 != NULL) 
+   {
+      R128_BT_SetEncoding(pPriv);
+      xf86_bt829_SetCaptSize(pPriv->bt829, width, height*2);
+   }
+   
+   if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
+   if(pPriv->msp3430 != NULL) R128_MSP_SetEncoding(pPriv);
+   if(pPriv->tda9850 != NULL)
+   { 
+      xf86_tda9850_mute(pPriv->tda9850, pPriv->mute);
+   }
+   }
+
+    /* update cliplist */
+    if(!REGION_EQUAL(pScrn->pScreen, &pPriv->clip, clipBoxes)) {
+	REGION_COPY(pScrn->pScreen, &pPriv->clip, clipBoxes);
+	/* draw these */
+	xf86XVFillKeyHelper(pScrn->pScreen, pPriv->colorKey, clipBoxes);
+    }
+
+    pPriv->doubleBuffer = 1;
+    R128DisplayVideo422(pScrn, pPriv, id, offset1 + top*srcPitch, offset2 + top*srcPitch, width, height, dstPitch,
+		     xa, xb, ya, &dstBox, src_w, src_h, drw_w, drw_h);
+
+    R128WaitForIdle(pScrn);
+
+    OUTREG(R128_OV0_REG_LOAD_CNTL, R128_REG_LD_CTL_LOCK);
+    while(!(INREG(R128_OV0_REG_LOAD_CNTL) &  R128_REG_LD_CTL_LOCK_READBACK));
+
+    OUTREG(R128_OV0_AUTO_FLIP_CNTL, R128_OV0_AUTO_FLIP_CNTL_SOFT_BUF_ODD|R128_OV0_AUTO_FLIP_CNTL_SHIFT_ODD_DOWN);
+
+    OUTREG (R128_OV0_AUTO_FLIP_CNTL, (INREG (R128_OV0_AUTO_FLIP_CNTL) ^ R128_OV0_AUTO_FLIP_CNTL_SOFT_EOF_TOGGLE  ));
+    OUTREG (R128_OV0_AUTO_FLIP_CNTL, (INREG (R128_OV0_AUTO_FLIP_CNTL) ^ R128_OV0_AUTO_FLIP_CNTL_SOFT_EOF_TOGGLE  ));
+
+    OUTREG(R128_OV0_DEINTERLACE_PATTERN, 0xAAAAA);
+
+    OUTREG(R128_OV0_REG_LOAD_CNTL, 0);
+
+    pPriv->videoStatus = CLIENT_VIDEO_ON;
+    pPriv->video_stream_active = TRUE;
+
+    info->VideoTimerCallback = R128VideoTimerCallback;
+
+    return Success;
+}
+
 static void
 R128VideoTimerCallback(ScrnInfoPtr pScrn, Time now)
 {
--- xf86-video-ati-6.6.192/src/Makefile.am.orig	2007-11-18 22:06:34.000000000 +0000
+++ xf86-video-ati-6.6.192/src/Makefile.am	2007-11-18 22:01:10.000000000 +0000
@@ -71,7 +71,7 @@
 r128_drv_ladir = @moduledir@/drivers
 r128_drv_la_SOURCES = \
 	r128_accel.c r128_cursor.c r128_dga.c r128_driver.c \
-	r128_video.c r128_misc.c r128_probe.c $(R128_DRI_SRCS)
+	r128_video.c r128_misc.c r128_probe.c $(R128_DRI_SRCS) r128_mm_i2c.c r128_vip.c
 
 radeon_drv_la_LTLIBRARIES = radeon_drv.la
 radeon_drv_la_LDFLAGS = -module -avoid-version
@@ -166,6 +166,7 @@
 	r128_reg.h \
 	r128_sarea.h \
 	r128_version.h \
+	r128_video.h \
 	radeon_chipset.h \
 	radeon_common.h \
 	radeon_commonfuncs.c \
--- xf86-video-ati-6.6.192/src/r128_mm_i2c.c.orig	2007-11-18 22:09:33.000000000 +0000
+++ xf86-video-ati-6.6.192/src/r128_mm_i2c.c	2007-11-19 22:02:12.000000000 +0000
@@ -0,0 +1,619 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "r128.h"
+#include "r128_reg.h"
+#include "r128_video.h"
+
+#include "xf86.h"
+#include "xf86PciInfo.h"
+
+/* i2c stuff */
+#include "xf86i2c.h"
+#include "fi1236.h"
+#include "msp3430.h"
+#include "tda9885.h"
+#include "i2c_def.h"
+
+#define I2C_DONE	(1<<0)
+#define I2C_NACK	(1<<1)
+#define I2C_HALT	(1<<2)
+#define I2C_SOFT_RST	(1<<5)
+#define I2C_DRIVE_EN	(1<<6)
+#define I2C_DRIVE_SEL	(1<<7)
+#define I2C_START	(1<<8)
+#define I2C_STOP	(1<<9)
+#define I2C_RECEIVE	(1<<10)
+#define I2C_ABORT	(1<<11)
+#define I2C_GO		(1<<12)
+#define I2C_SEL		(1<<16)
+#define I2C_EN		(1<<17)
+
+
+/****************************************************************************
+ *  I2C_WaitForAck (void)                                                   *
+ *                                                                          *
+ *  Function: polls the I2C status bits, waiting for an acknowledge or      *
+ *            an error condition.                                           *
+ *    Inputs: NONE                                                          *
+ *   Outputs: I2C_DONE - the I2C transfer was completed                     *
+ *            I2C_NACK - an NACK was received from the slave                *
+ *            I2C_HALT - a timeout condition has occured                    *
+ ****************************************************************************/
+static CARD8 R128_I2C_WaitForAck (ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    CARD8 retval = 0;
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+    long counter = 0;
+
+    usleep(1000);
+    while(1)
+    {
+        retval = INREG8(R128_I2C_CNTL_0);
+        if (retval & I2C_HALT)
+        {
+            return (I2C_HALT);
+        }
+        if (retval & I2C_NACK)
+        {
+            return (I2C_NACK);
+        }
+	if (retval & I2C_DONE)
+	{
+	    return (I2C_DONE);
+	}
+	counter++;
+	if(counter>1000000)
+	{
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Timeout condition on rage128 i2c bus\n");
+		return (I2C_HALT);
+	}
+		
+    }
+}
+
+static void R128_I2C_Halt (ScrnInfoPtr pScrn)
+{
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+    CARD8    reg;
+    long counter = 0;
+
+    /* reset status flags */
+    reg = INREG8 (R128_I2C_CNTL_0 + 0) & 0xF8;
+    OUTREG8 (R128_I2C_CNTL_0 + 0, reg);
+
+    /* issue ABORT call */
+    reg = INREG8 (R128_I2C_CNTL_0 + 1) & 0xE7;
+    OUTREG8 (R128_I2C_CNTL_0 + 1, (reg | 0x18));
+
+    /* wait for GO bit to go low */
+    while (INREG8 (R128_I2C_CNTL_0 + 1) & (I2C_GO >> 8))
+    {
+       counter++;
+       if(counter>1000000)return;
+    }
+
+} 
+
+
+
+static Bool R128I2CWriteRead(I2CDevPtr d, I2CByte *WriteBuffer, int nWrite,
+                            I2CByte *ReadBuffer, int nRead)
+{
+    int loop, status;
+    CARD32 i2c_cntl_0, i2c_cntl_1;
+    R128PortPrivPtr pPriv = (R128PortPrivPtr)(d->pI2CBus->DriverPrivate.ptr);
+    ScrnInfoPtr pScrn = xf86Screens[d->pI2CBus->scrnIndex];
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+
+    status=I2C_DONE;
+
+    if(nWrite>0){
+      R128WaitForFifo(pScrn, 4+nWrite);
+
+      /* Clear the status bits of the I2C Controller */
+      OUTREG(R128_I2C_CNTL_0, I2C_DONE | I2C_NACK | I2C_HALT | I2C_SOFT_RST);
+
+      /* Write the address into the buffer first */
+      OUTREG(R128_I2C_DATA, (CARD32) (d->SlaveAddr) & ~(1));
+
+      /* Write Value into the buffer */
+      for (loop = 0; loop < nWrite; loop++)
+      {
+        OUTREG8(R128_I2C_DATA, WriteBuffer[loop]);
+      }
+
+      i2c_cntl_1 = (pPriv->r128_i2c_timing << 24) | I2C_EN | I2C_SEL | 
+    			nWrite | 0x100;
+      OUTREG(R128_I2C_CNTL_1, i2c_cntl_1);
+    
+      i2c_cntl_0 = (pPriv->r128_N << 24) | (pPriv->r128_M << 16) | 
+    			I2C_GO | (1<<8) | (((nRead>0)?0:1) << 9) | I2C_DRIVE_EN;
+      OUTREG(R128_I2C_CNTL_0, i2c_cntl_0);
+    
+      while(INREG8(R128_I2C_CNTL_0+1) & (I2C_GO >> 8));
+
+      status=R128_I2C_WaitForAck(pScrn,pPriv);
+
+      if(status!=I2C_DONE){
+      	R128_I2C_Halt(pScrn);
+      	return FALSE;
+	}
+    }
+    
+    if(nRead > 0) {
+      R128WaitForFifo(pScrn, 4+nRead);
+    
+      OUTREG(R128_I2C_CNTL_0, 0x27);
+
+      /* Write the address into the buffer first */
+      OUTREG(R128_I2C_DATA, (CARD32) (d->SlaveAddr) | (1));
+
+      i2c_cntl_1 = (pPriv->r128_i2c_timing << 24) | I2C_EN | I2C_SEL | 
+    			nRead | 0x100;
+      OUTREG(R128_I2C_CNTL_1, i2c_cntl_1);
+    
+      i2c_cntl_0 = (pPriv->r128_N << 24) | (pPriv->r128_M << 16) | 
+    			I2C_GO | (1<<8) | ((1) << 9) | I2C_DRIVE_EN | I2C_RECEIVE;
+      OUTREG(R128_I2C_CNTL_0, i2c_cntl_0);
+    
+      while(INREG8(R128_I2C_CNTL_0+1) & (I2C_GO >> 8));
+
+      status=R128_I2C_WaitForAck(pScrn,pPriv);
+
+      /* Write Value into the buffer */
+      for (loop = 0; loop < nRead; loop++)
+      {
+        R128WaitForFifo(pScrn, 1);
+	if((status == I2C_HALT) || (status == I2C_NACK))
+	{
+	ReadBuffer[loop]=0xff;
+	} else {
+        ReadBuffer[loop]=INREG8(R128_I2C_DATA) & 0xff;
+	}
+      }
+
+    }
+    
+    if(status!=I2C_DONE){
+    	R128_I2C_Halt(pScrn);
+    	return FALSE;
+	}
+    return TRUE;
+}
+
+static Bool R128ProbeAddress(I2CBusPtr b, I2CSlaveAddr addr)
+{
+     I2CByte a;
+     I2CDevRec d;
+     
+     d.DevName = "Probing";
+     d.SlaveAddr = addr;
+     d.pI2CBus = b;
+     d.NextDev = NULL;
+     
+     return I2C_WriteRead(&d, NULL, 0, &a, 1);
+}
+
+
+#define I2C_CLOCK_FREQ     (80000.0)
+
+const struct 
+{
+   char *name; 
+   int type;
+} R128_tuners[32] =
+    {
+        /* name	,index to tuner_parms table */
+	{"NO TUNNER"		, -1},
+	{"FI1236"		, TUNER_TYPE_FI1236},
+	{"FI1236"		, TUNER_TYPE_FI1236},
+	{"FI1216"		, TUNER_TYPE_FI1216},
+	{"FI1246"		, TUNER_TYPE_FI1246},
+	{"FI1216MF"		, TUNER_TYPE_FI1216},
+	{"FI1236"		, TUNER_TYPE_FI1236},
+	{"FI1256"		, TUNER_TYPE_FI1256},
+	{"FI1236"		, TUNER_TYPE_FI1236},
+	{"FI1216"		, TUNER_TYPE_FI1216},
+	{"FI1246"		, TUNER_TYPE_FI1246},
+	{"FI1216MF"		, TUNER_TYPE_FI1216},
+	{"FI1236"		, TUNER_TYPE_FI1236},
+	{"TEMIC-FN5AL"		, TUNER_TYPE_TEMIC_FN5AL},
+	{"FQ1216ME/P"		, TUNER_TYPE_FI1216},
+	{"UNKNOWN-15"		, -1},
+	{"Alps TSBH5"		, -1},
+	{"Alps TSCxx"		, -1},
+	{"Alps TSCH5 FM"	, -1},
+	{"UNKNOWN-19"		, -1},
+	{"UNKNOWN-20"		, -1},
+	{"UNKNOWN-21"		, -1},
+	{"UNKNOWN-22"		, -1},
+	{"UNKNOWN-23"		, -1},
+        {"UNKNOWN-24"		, -1},
+	{"UNKNOWN-25"		, -1},
+	{"UNKNOWN-26"		, -1},
+	{"UNKNOWN-27"		, -1},
+	{"UNKNOWN-28"		, -1},
+	{"UNKNOWN-29"		, -1},
+        {"UNKNOWN-30"		, -1},
+	{"UNKNOWN-31"		, -1}
+    };
+
+void R128ResetI2C(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+
+    OUTREG8(R128_I2C_CNTL_1+2, ((I2C_SEL | I2C_EN)>>16));
+    OUTREG8(R128_I2C_CNTL_0+0, (I2C_DONE | I2C_NACK | I2C_HALT | I2C_SOFT_RST | I2C_DRIVE_EN | I2C_DRIVE_SEL));
+}
+
+
+static int R128_addon_addresses[] = { 0x70, 0x40, 0x78, 0x72, 0x42, 0};
+
+static void R128DetectAddon(R128PortPrivPtr pPriv)
+{
+   I2CDevRec d;
+   CARD8 data[1];
+   int i;
+   if(pPriv->i2c == NULL) return;
+   
+   d.DevName = "temporary";
+   d.pI2CBus = pPriv->i2c;
+   d.NextDev = NULL;
+   d.StartTimeout = pPriv->i2c->StartTimeout;
+   d.BitTimeout = pPriv->i2c->BitTimeout;
+   d.AcknTimeout = pPriv->i2c->AcknTimeout;
+   d.ByteTimeout = pPriv->i2c->ByteTimeout;
+   pPriv->addon_board = FALSE;
+
+   for(i=0;R128_addon_addresses[i];i++)
+   {
+     d.SlaveAddr = R128_addon_addresses[i];
+     data[0]=0xFF;
+     if(!I2C_WriteRead(&d, data, 1, NULL, 0))continue;
+     if(!I2C_WriteRead(&d, NULL, 0, data, 1))continue;
+     if((data[0] == 0xFF) || (data[0] == 0x00))continue;
+     pPriv->addon_board = TRUE;
+     pPriv->board_control = R128_addon_addresses[i];
+     pPriv->board_info = data[0];
+     xf86DrvMsg(pPriv->i2c->scrnIndex, X_INFO, "Standalone board at addr 0x%02x found, returned 0x%02x\n",
+         d.SlaveAddr,
+     	 data[0]);
+     R128BoardSetmisc(pPriv);
+     break;
+   }
+
+
+}
+
+static int R128_eeprom_addresses[] = { 0xA8, 0x70, 0x40, 0x78, 0x72, 0x42, 0};
+
+static void R128ReadEEPROM(R128PortPrivPtr pPriv)
+{
+   I2CDevRec d;
+   unsigned char data[5];
+   int i;
+   if(pPriv->i2c == NULL) return;
+   
+   d.DevName = "temporary";
+   d.pI2CBus = pPriv->i2c;
+   d.NextDev = NULL;
+   d.StartTimeout = pPriv->i2c->StartTimeout;
+   d.BitTimeout = pPriv->i2c->BitTimeout;
+   d.AcknTimeout = pPriv->i2c->AcknTimeout;
+   d.ByteTimeout = pPriv->i2c->ByteTimeout;
+   pPriv->EEPROM_addr = 0;
+
+   for(i=0;R128_eeprom_addresses[i];i++)
+   {
+     d.SlaveAddr = R128_eeprom_addresses[i];
+     data[0]=0x00;
+     if(!I2C_WriteRead(&d, data, 1, NULL, 0))continue;
+     if(!I2C_WriteRead(&d, NULL, 0, data, 5))continue;
+     if(!memcmp(data, "ATI", 3))
+     {
+        pPriv->EEPROM_present = TRUE;
+	pPriv->EEPROM_addr = R128_eeprom_addresses[i];
+	break;
+     }
+     xf86DrvMsg(pPriv->i2c->scrnIndex, X_INFO, "Device at eeprom addr 0x%02x found, returned 0x%02x-0x%02x-0x%02x-0x%02x-0x%02x\n",
+         d.SlaveAddr,
+     	 data[0], data[1], data[2], data[3], data[4]);
+   }
+
+
+}
+
+
+/* this routine is here because different mach64/r128 boards use
+   different methods of muting. And because sometimes there is
+   no good way to autodetect this (besides knowing which board
+   we have) */
+
+
+
+void R128BoardSetmisc(R128PortPrivPtr pPriv)
+{
+    CARD8 a;
+    I2CDevRec d;
+
+    d.DevName = "temporary";
+    d.pI2CBus = pPriv->i2c;
+    d.NextDev = NULL;
+    d.StartTimeout = pPriv->i2c->StartTimeout;
+    d.BitTimeout = pPriv->i2c->BitTimeout;
+    d.AcknTimeout = pPriv->i2c->AcknTimeout;
+    d.ByteTimeout = pPriv->i2c->ByteTimeout;
+
+    if(pPriv->addon_board)
+    {
+       a = 0x2F;
+       if(!pPriv->mute && pPriv->video_stream_active) a |= 0x50;
+       if(((pPriv->encoding-1) % 3) != 1) a |= 0x40; 
+       d.SlaveAddr = pPriv->board_control;
+       I2C_WriteRead(&d, &a, 1, NULL, 0);    
+    }
+
+    if(pPriv->tda8425 != NULL)
+    {
+       pPriv->tda8425->v_left = (pPriv->mute ? 0xc0 : 0xff);
+       pPriv->tda8425->v_right = (pPriv->mute ? 0xc0 : 0xff);
+       if(((pPriv->encoding-1) % 3) != 1) pPriv->tda8425->mux = 0;
+                         else pPriv->tda8425->mux = 1; /* this is a fancy way
+                                                    to choose all encodings
+						    except tuner ones */ 
+       xf86_tda8425_setaudio(pPriv->tda8425);
+    }
+
+    /* Adjust PAL/SECAM constants for FI1216MF tuner */
+    if((((pPriv->board_info & 0xf)==5) ||
+       ((pPriv->board_info & 0xf)==11) ||
+       ((pPriv->board_info & 0xf)==14))&& (pPriv->fi1236!=NULL))
+    {
+        if((pPriv->encoding>=1)&&(pPriv->encoding<=3)) /*PAL*/
+	{
+    	   pPriv->fi1236->parm.band_low = 0xA1;
+	   pPriv->fi1236->parm.band_mid = 0x91;
+	   pPriv->fi1236->parm.band_high = 0x31;
+	}
+        if((pPriv->encoding>=7)&&(pPriv->encoding<=9)) /*SECAM*/
+	{
+    	   pPriv->fi1236->parm.band_low = 0xA3;
+	   pPriv->fi1236->parm.band_mid = 0x93;
+	   pPriv->fi1236->parm.band_high = 0x33;
+	}
+    }
+
+    R128MuteAudio(pPriv, pPriv->mute);
+}
+
+void R128InitI2C(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    double nm;
+    R128InfoPtr info = R128PTR(pScrn);
+    R128PLLPtr  pll = &(info->pll);
+
+    pPriv->fi1236 = NULL;
+    pPriv->bt829 = NULL;
+    pPriv->tda9850 = NULL;
+    pPriv->msp3430 = NULL;
+    
+    if(pPriv->i2c==NULL) {
+    if(!xf86LoadSubModule(pScrn,"i2c")) {
+    	xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Unable to initialize i2c bus\n");
+	pPriv->i2c=NULL;
+	return;
+        } 
+    xf86LoaderReqSymbols("xf86CreateI2CBusRec", 
+    			  "xf86I2CBusInit",
+			  "xf86DestroyI2CBus",
+			  "xf86CreateI2CDevRec",
+			  "xf86DestroyI2CDevRec",
+			  "xf86I2CDevInit",
+			  "xf86I2CWriteRead",
+			  NULL);
+    pPriv->i2c=CreateI2CBusRec();
+    pPriv->i2c->scrnIndex=pScrn->scrnIndex;
+    pPriv->i2c->BusName="Rage 128 multimedia bus";
+    pPriv->i2c->DriverPrivate.ptr=(pointer)pPriv;
+    pPriv->i2c->I2CWriteRead=R128I2CWriteRead;
+    if(!I2CBusInit(pPriv->i2c)){
+    	xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Failed to register i2c bus\n");
+    	}
+    }
+
+    nm=(pll->reference_freq * 10000.0)/(4.0 * I2C_CLOCK_FREQ);
+    for(pPriv->r128_N=1; pPriv->r128_N<255; pPriv->r128_N++)
+          if((pPriv->r128_N * (pPriv->r128_N-1)) > nm)break;
+    pPriv->r128_M=pPriv->r128_N-1;
+    pPriv->r128_i2c_timing=2*pPriv->r128_N;
+    
+    R128ResetI2C(pScrn, pPriv);
+
+       /* You can't attach addon card to a notebook */
+    if(!info->MM_TABLE_valid && 
+                 (((info->Chipset != PCI_CHIP_RAGE128LE) &&
+		 (info->Chipset != PCI_CHIP_RAGE128LF) &&
+		 (info->Chipset != PCI_CHIP_RAGE128MF) &&
+		 (info->Chipset != PCI_CHIP_RAGE128ML)) || 
+		 info->forceI2CProbing))R128DetectAddon(pPriv);
+    	  else pPriv->addon_board = FALSE;
+    
+    /* no multimedia capabilities detected */
+    /* the following code _will_ lockup with MobilityM3 and no i2c device attached 
+       at the moment no safe way is known to detect this (as BIOS has no multimedia table) */ 
+    if(!info->MM_TABLE_valid && !pPriv->addon_board)
+    {
+       if(!info->forceI2CProbing){
+	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No video input capabilities detected\n");
+       	       return;
+	       } else {
+	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No video input capabilities detected, but continuing anyway.\n");
+	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Don't be surprised if the system locks up.\n");
+	       }	       
+    }
+
+    if(!xf86LoadSubModule(pScrn,"fi1236"))
+    {
+    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to initialize fi1236 driver\n");
+    }
+    else
+    {
+    xf86LoaderReqSymbols(FI1236SymbolsList, NULL);
+    if(pPriv->fi1236 == NULL)
+    {
+    	pPriv->fi1236 = xf86_Detect_FI1236(pPriv->i2c, FI1236_ADDR_1);
+    }
+    if(pPriv->fi1236 == NULL)
+    {
+    	pPriv->fi1236 = xf86_Detect_FI1236(pPriv->i2c, FI1236_ADDR_2);
+    }
+    }
+    if(pPriv->fi1236 != NULL)
+    {
+         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Detected %s device at 0x%02x\n", 
+	       R128_tuners[pPriv->board_info & 0x0f].name,
+               FI1236_ADDR(pPriv->fi1236));
+               xf86_FI1236_set_tuner_type(pPriv->fi1236, R128_tuners[pPriv->board_info & 0x0f].type);
+    }
+
+    if(!xf86LoadSubModule(pScrn, "bt829"))
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to initialize bt829 driver\n");
+    } else 
+    {
+      xf86LoaderReqSymbols(BT829SymbolsList, NULL);
+      if(pPriv->bt829 == NULL)
+      {
+         pPriv->bt829 = xf86_bt829_Detect(pPriv->i2c, BT829_ATI_ADDR_1);
+      }
+      if(pPriv->bt829 == NULL)
+      {
+         pPriv->bt829 = xf86_bt829_Detect(pPriv->i2c, BT829_ATI_ADDR_2);
+      }
+      if(pPriv->bt829 != NULL)
+      {
+	 pPriv->bt829->tunertype = pPriv->board_info & 0x0f;
+         if(xf86_bt829_ATIInit(pPriv->bt829) < 0)pPriv->bt829 = NULL; /* disable it */
+         if(info->MM_TABLE_valid && (pPriv->bt829!=NULL))
+         {
+           xf86_bt829_SetP_IO(pPriv->bt829, 0x02); /* mute */
+           xf86_bt829_SetOUT_EN(pPriv->bt829, 1);
+         }
+      }
+    }
+
+}
+
+  
+  
+void R128InitI2CAudio(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    R128InfoPtr info = R128PTR(pScrn);
+
+    if((pPriv->bt829 == NULL) && (pPriv->theatre == NULL))
+             /* No decoder found. No sense initializing audio chips */
+    {
+       return;
+    }
+
+    if(!xf86LoadSubModule(pScrn, "msp3430"))
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to initialize msp3430 driver\n");
+    } 
+    else 
+    {
+    xf86LoaderReqSymbols(MSP3430SymbolsList, NULL);
+    if(pPriv->msp3430 == NULL)
+    {
+       pPriv->msp3430 = xf86_DetectMSP3430(pPriv->i2c, MSP3430_ADDR_1);
+    }
+    if(pPriv->msp3430 == NULL)
+    {
+       pPriv->msp3430 = xf86_DetectMSP3430(pPriv->i2c, MSP3430_ADDR_2);
+    }
+#if 0  /* this would confuse bt829 with MSP3430 */
+    if(pPriv->msp3430 == NULL)
+    {
+       pPriv->msp3430 = xf86_DetectMSP3430(pPriv->i2c, MSP3430_ADDR_3);
+    }
+#endif
+    }
+    if(pPriv->msp3430 != NULL)
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Detected MSP3430 at 0x%02x\n", 
+                 MSP3430_ADDR(pPriv->msp3430));
+    }
+
+    if(!xf86LoadSubModule(pScrn, "tda9850"))
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to initialize tda9850 driver\n");
+    } else 
+    {
+       xf86LoaderReqSymbols(TDA9850SymbolsList, NULL);
+       if(pPriv->tda9850 == NULL)
+       {
+          pPriv->tda9850 = xf86_Detect_tda9850(pPriv->i2c, TDA9850_ADDR_1);
+       }
+       if(pPriv->tda9850 != NULL)
+       {
+          if(!xf86_tda9850_init(pPriv->tda9850))pPriv->tda9850 = NULL; /* disable it */
+       }
+       if(pPriv->tda9850 != NULL)
+       {
+          xf86_tda9850_setaudio(pPriv->tda9850);
+	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "tda9850 status 0x%04x\n", xf86_tda9850_getstatus(pPriv->tda9850));
+       }  
+    }
+    if(!xf86LoadSubModule(pScrn, "tda8425"))
+    {
+       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Unable to initialize tda8425 driver\n");
+    } else 
+    {
+       /* Bug bug bug. I don't know how to probe a write-only device properly with Rage 128
+          hardware assisted  i2c. Help ?! */
+       xf86LoaderReqSymbols(TDA8425SymbolsList, NULL);
+       if((pPriv->tda8425 == NULL) && !info->MM_TABLE_valid)
+       {
+          pPriv->tda8425 = xf86_Detect_tda8425(pPriv->i2c, TDA8425_ADDR_1, TRUE);
+       }
+       if(pPriv->tda8425 != NULL)
+       {
+          if(!xf86_tda8425_init(pPriv->tda8425))pPriv->tda8425 = NULL; /* disable it */
+       }
+    }
+
+   if(pPriv->i2c!=NULL) R128BoardSetmisc(pPriv);
+}
+
+void R128MuteAudio(R128PortPrivPtr pPriv, Bool mute)
+{
+  pPriv->mute=mute;
+  if (pPriv->msp3430 != NULL) xf86_MSP3430SetVolume(pPriv->msp3430, mute ? MSP3430_FAST_MUTE : MSP3430_VOLUME(pPriv->volume));
+  if (pPriv->tda9850 != NULL) xf86_tda9850_mute(pPriv->tda9850, mute);
+  if (pPriv->tda8425 != NULL) xf86_tda8425_mute(pPriv->tda8425, mute);
+  if ((pPriv->bt829 != NULL) && (pPriv->bt829->out_en)) {
+    if (mute) xf86_bt829_SetP_IO(pPriv->bt829, 0x02);
+    else {
+      switch (pPriv->bt829->mux) {
+        case BT829_MUX2:
+          xf86_bt829_SetP_IO(pPriv->bt829, 0x00);
+          break;
+        case BT829_MUX0:
+          xf86_bt829_SetP_IO(pPriv->bt829, 0x01);
+          break;
+        case BT829_MUX1:
+          xf86_bt829_SetP_IO(pPriv->bt829, 0x00);
+          break;
+        default: /* shouldn't get here */
+          xf86_bt829_SetP_IO(pPriv->bt829, 0x00); /* hardware default */
+          break;
+      }
+    }
+  }
+}
--- xf86-video-ati-6.6.192/src/r128_vip.c.orig	2007-11-18 22:09:38.000000000 +0000
+++ xf86-video-ati-6.6.192/src/r128_vip.c	2007-11-19 22:02:22.000000000 +0000
@@ -0,0 +1,194 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "r128.h"
+#include "r128_reg.h"
+#include <X11/extensions/Xv.h>
+#include "r128_video.h"
+
+#include "xf86.h"
+#include "xf86PciInfo.h"
+
+#include "generic_bus.h"
+
+#define VIP_NAME      "R128 VIP BUS"
+#define VIP_TYPE      "ATI VIP BUS"
+
+/* Status defines */
+#define VIP_BUSY  0
+#define VIP_IDLE  1
+#define VIP_RESET 2
+
+static Bool R128VIP_ioctl(GENERIC_BUS_Ptr b, long ioctl, long arg1, char *arg2)
+{
+    long count;
+    switch(ioctl){
+        case GB_IOCTL_GET_NAME:
+                  count=strlen(VIP_NAME)+1;
+                  if(count>arg1)return FALSE;
+                  memcpy(arg2,VIP_NAME,count);
+                  return TRUE;
+                  
+        case GB_IOCTL_GET_TYPE:
+                  count=strlen(VIP_TYPE)+1;
+                  if(count>arg1)return FALSE;
+                  memcpy(arg2,VIP_TYPE,count);
+                  return TRUE;
+                  
+        default: 
+                  return FALSE;
+    }
+}
+
+static CARD32 R128VIP_idle(GENERIC_BUS_Ptr b)
+{
+   ScrnInfoPtr pScrn = xf86Screens[b->scrnIndex];
+   R128InfoPtr info = R128PTR(pScrn);
+   unsigned char *R128MMIO = info->MMIO;
+
+   CARD32 timeout;
+   
+   R128WaitForIdle(pScrn);
+   timeout = INREG(R128_VIPH_TIMEOUT_STAT);
+   if(timeout & R128_VIPH_TIMEOUT_STAT__VIPH_REG_STAT) /* lockup ?? */
+   {
+       R128WaitForFifo(pScrn, 2);
+       OUTREG(R128_VIPH_TIMEOUT_STAT, (timeout & 0xffffff00) | R128_VIPH_TIMEOUT_STAT__VIPH_REG_AK);
+       R128WaitForIdle(pScrn);
+       return (INREG(R128_VIPH_CONTROL) & 0x2000) ? VIP_BUSY : VIP_RESET;
+   }
+   R128WaitForIdle(pScrn);
+   return (INREG(R128_VIPH_CONTROL) & 0x2000) ? VIP_BUSY : VIP_IDLE ;
+}
+
+/* address format:
+     ((device & 0x3)<<14)   | (fifo << 12) | (addr)
+*/
+
+static Bool R128VIP_read(GENERIC_BUS_Ptr b, CARD32 address, CARD32 count, CARD8 *buffer)
+{
+   ScrnInfoPtr pScrn = xf86Screens[b->scrnIndex];
+   R128InfoPtr info = R128PTR(pScrn);
+   unsigned char *R128MMIO = info->MMIO;
+   CARD32 status,tmp;
+
+   if((count!=1) && (count!=2) && (count!=4))
+   {
+   xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Attempt to access VIP bus with non-stadard transaction length\n");
+   return FALSE;
+   }
+   
+   R128WaitForFifo(pScrn, 2);
+   OUTREG(R128_VIPH_REG_ADDR, address | 0x2000);
+   write_mem_barrier();
+   while(VIP_BUSY == (status = R128VIP_idle(b)));
+   if(VIP_IDLE != status) return FALSE;
+   
+/*
+         disable R128_VIPH_REGR_DIS to enable VIP cycle.
+         The LSB of R128_VIPH_TIMEOUT_STAT are set to 0
+         because 1 would have acknowledged various VIP
+         interrupts unexpectedly 
+*/      
+   R128WaitForIdle(pScrn);
+   OUTREG(R128_VIPH_TIMEOUT_STAT, INREG(R128_VIPH_TIMEOUT_STAT) & (0xffffff00 & ~R128_VIPH_TIMEOUT_STAT__VIPH_REGR_DIS) );
+   write_mem_barrier();
+/*
+         the value returned here is garbage.  The read merely initiates
+         a register cycle
+*/
+    R128WaitForIdle(pScrn);
+    INREG(R128_VIPH_REG_DATA);
+    
+    while(VIP_BUSY == (status = R128VIP_idle(b)));
+    if(VIP_IDLE != status) return FALSE;
+/*
+        set R128_VIPH_REGR_DIS so that the read won't take too long.
+*/
+    R128WaitForIdle(pScrn);
+    tmp=INREG(R128_VIPH_TIMEOUT_STAT);
+    OUTREG(R128_VIPH_TIMEOUT_STAT, (tmp & 0xffffff00) | R128_VIPH_TIMEOUT_STAT__VIPH_REGR_DIS);         
+    write_mem_barrier();
+    R128WaitForIdle(pScrn);
+    switch(count){
+        case 1:
+             *buffer=(CARD8)(INREG(R128_VIPH_REG_DATA) & 0xff);
+             break;
+        case 2:
+             *(CARD16 *)buffer=(CARD16) (INREG(R128_VIPH_REG_DATA) & 0xffff);
+             break;
+        case 4:
+             *(CARD32 *)buffer=(CARD32) ( INREG(R128_VIPH_REG_DATA) & 0xffffffff);
+             break;
+        }
+     while(VIP_BUSY == (status = R128VIP_idle(b)));
+     if(VIP_IDLE != status) return FALSE;
+ /*     
+ so that reading R128_VIPH_REG_DATA would not trigger unnecessary vip cycles.
+*/
+     OUTREG(R128_VIPH_TIMEOUT_STAT, (INREG(R128_VIPH_TIMEOUT_STAT) & 0xffffff00) | R128_VIPH_TIMEOUT_STAT__VIPH_REGR_DIS);
+     write_mem_barrier();
+     return TRUE;
+}
+
+static Bool R128VIP_write(GENERIC_BUS_Ptr b, CARD32 address, CARD32 count, CARD8 *buffer)
+{
+    ScrnInfoPtr pScrn = xf86Screens[b->scrnIndex];
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+    
+    CARD32 status;
+
+
+    if((count!=4))
+    {
+    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Attempt to access VIP bus with non-stadard transaction length\n");
+    return FALSE;
+    }
+    
+    R128WaitForFifo(pScrn, 2);
+    OUTREG(R128_VIPH_REG_ADDR, address & (~0x2000));
+    while(VIP_BUSY == (status = R128VIP_idle(b)));
+    
+    if(VIP_IDLE != status) return FALSE;
+    
+    R128WaitForFifo(pScrn, 2);
+    switch(count){
+        case 4:
+             OUTREG(R128_VIPH_REG_DATA, *(CARD32 *)buffer);
+             break;
+        }
+    write_mem_barrier();
+    while(VIP_BUSY == (status = R128VIP_idle(b)));
+    if(VIP_IDLE != status) return FALSE;
+    return TRUE;
+}
+
+void R128VIP_reset(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    R128InfoPtr info = R128PTR(pScrn);
+    unsigned char *R128MMIO = info->MMIO;
+
+
+    R128WaitForIdle(pScrn);
+    OUTREG(R128_VIPH_CONTROL, 0x003F0004); /* slowest, timeout in 16 phases */
+    OUTREG(R128_VIPH_TIMEOUT_STAT, (INREG(R128_VIPH_TIMEOUT_STAT) & 0xFFFFFF00) | R128_VIPH_TIMEOUT_STAT__VIPH_REGR_DIS);
+    OUTREG(R128_VIPH_DV_LAT, 0x444400FF); /* set timeslice */
+    OUTREG(R128_VIPH_BM_CHUNK, 0x151);
+    OUTREG(R128_TEST_DEBUG_CNTL, INREG(R128_TEST_DEBUG_CNTL) & (~R128_TEST_DEBUG_CNTL__TEST_DEBUG_OUT_EN));
+    OUTREG(R128_MPP_GP_CONFIG, 0);
+    OUTREG(R128_MPP_TB_CONFIG, 0);
+}
+
+void R128VIP_init(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv)
+{
+    pPriv->VIP=xcalloc(1,sizeof(GENERIC_BUS_Rec));
+    pPriv->VIP->scrnIndex=pScrn->scrnIndex;
+    pPriv->VIP->DriverPrivate.ptr=pPriv;
+    pPriv->VIP->ioctl=R128VIP_ioctl;
+    pPriv->VIP->read=R128VIP_read;
+    pPriv->VIP->write=R128VIP_write;
+    
+    R128VIP_reset(pScrn, pPriv);
+}
--- xf86-video-ati-6.6.192/src/r128_video.h.orig	2007-11-18 22:09:49.000000000 +0000
+++ xf86-video-ati-6.6.192/src/r128_video.h	2004-12-23 02:08:08.000000000 +0000
@@ -0,0 +1,76 @@
+#ifndef __R128_VIDEO_H__
+#define __R128_VIDEO_H__
+
+#include "xf86i2c.h"
+#include "fi1236.h"
+#include "msp3430.h"
+#include "tda9850.h"
+#include "tda8425.h"
+#include "bt829.h"
+#include "i2c_def.h"
+
+#include "generic_bus.h"
+#include "theatre.h"
+
+typedef struct {
+   int           brightness;
+   int           saturation;
+   int           contrast;
+   int           hue;
+   Bool          doubleBuffer;
+   unsigned char currentBuffer;
+   FBLinearPtr   linear;
+   RegionRec     clip;
+   CARD32        colorKey;
+   CARD32        videoStatus;
+   Time          offTime;
+   Time          freeTime;
+   
+   I2CBusPtr	 i2c;
+   CARD32 	 r128_i2c_timing;
+   CARD32        r128_M;
+   CARD32        r128_N;
+
+   FI1236Ptr     fi1236;
+   MSP3430Ptr    msp3430;
+   BT829Ptr	 bt829;
+   TDA9850Ptr	 tda9850;
+   TDA8425Ptr    tda8425;
+   
+   GENERIC_BUS_Ptr VIP;
+   TheatrePtr      theatre;
+   
+   Bool          video_stream_active;
+   int           encoding;
+   CARD32        frequency;
+   int           volume;
+   Bool		 mute;
+   int		 sap_channel;
+   int           v;
+   int           ecp_div;
+
+   Bool		 EEPROM_present;
+   int		 EEPROM_addr;
+
+   Bool          addon_board;
+   CARD8         board_info;
+   int           board_control;
+
+   Bool          autopaint_colorkey;
+
+   Atom		 device_id, location_id, instance_id;
+} R128PortPrivRec, *R128PortPrivPtr;
+
+   /* r128_mm_i2c.c */
+void R128ResetI2C(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv);
+void R128InitI2C(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv);
+void R128BoardSetmisc(R128PortPrivPtr pPriv);
+void R128InitI2CAudio(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv);
+void R128MuteAudio(R128PortPrivPtr pPriv, Bool mute);
+
+   /* r128_vip.c */
+void R128VIP_reset(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv);
+void R128VIP_init(ScrnInfoPtr pScrn, R128PortPrivPtr pPriv);
+
+
+#endif
